---
title: "Instroomanalyse `r params$school_name` `r params$year` (`r params$brin_code`)"
subtitle: "Data kwaliteit en conversie analyse"
author: "Corneel den Hartogh"
date: "`r format(Sys.time(), '%d %B %Y')`"
params:
  brin_code: "30RR"
  school_name: "MBO Amersfoort"
  year: 2024
format: 
  html:
    toc: true
    toc-title: Inhoudsopgave
    code-fold: true
    code-summary: "Laat code zien"
execute:
  cache: true
  freeze: auto
  include: true
  warning: false
---

```{r}
#| label: setup
#| cache: false
#| output: false
#| include: false
#| freeze: false

# Load pipeline functions
source("utils/00_setup.R")

# Set default params if not available (for testing)
if (!exists("params")) {
  params <- list(
    brin_code = "30RR",
    school_name = "MBO Amersfoort", 
    comparison_mode = "relative_to_average",
    year = 2024
  )
}

```

## Executive Summary

Deze analyse toont de instroompatronen en data kwaliteit voor **`r params$school_name`** (BRIN: `r params$brin_code`) voor de schooljaren `r paste(params$year, collapse = " en ")`.

```{r}
#| label: load-data-full-dataset
#| cache: true

# STAP 1: ALGEMENE ANALYSES OP VOLLEDIGE DATASET
# Load complete applications data (alle instellingen)
# Laad voorbereide datasets uit data_preparation.qmd
all_applications <- read_csv(
  paste0("data/02_prepared/applications_enriched_with_context",
         config::get("suffix"),
         ".csv"),
  show_col_types = FALSE)

cat("Volledige dataset geladen voor alle instellingen\n")
cat("Totaal aantal rijen:", nrow(all_applications), "\n")
cat("Aantal unieke BRIN codes:", length(unique(all_applications$instellingserkenningscode)), "\n")

```

```{r}
#| label: general-analysis-multiple-institutions
#| cache: true

# STAP 2: ANALYSES DIE MEERDERE INSTELLINGEN NODIG HEBBEN
# Group applications op volledig niveau voor meervoudige aanmeldingen analyse
grouped_all_applications <- group_applications(all_applications)


# Analyseer meervoudige aanmeldingen over alle instellingen
multiple_applications_analysis <- analyze_multiple_applications(grouped_all_applications)


```

```{r}
#| label: filter-institution-data
#| cache: true

# STAP 3: FILTER VOOR SPECIFIEKE INSTELLING
# Nu filteren we voor de specifieke instelling
institution_data <- filter_applications_on_brin(all_applications, brin_codes = params$brin_code)

# Group applications voor deze instelling
grouped_institution <- group_applications(institution_data, "full")

cat("Data gefilterd voor", params$school_name, "\n")
cat("Aantal rijen voor deze instelling:", nrow(institution_data), "\n")
cat("Aantal gegroepeerde aanmeldingen:", nrow(grouped_institution), "\n")

```

## 1. Basis Statistieken

Deze sectie toont de kernstatistieken voor `r params$school_name`. We analyseren het totale volume van aanmeldingen, het aantal unieke studenten, en de conversie van aanmelding naar inschrijving.

```{r}
#| label: basic-stats

# Calculate statistics for this institution
institution_stats <- calculate_summary_stats(institution_data, "full")

# Create basic statistics table
basic_stats <- data.frame(
  Metriek = c("Totaal aanmeldingen", "Unieke studenten", "Conversie ratio", "Aanmeldingen per student"),
  Waarde = c(
    format(institution_stats$total_applications, big.mark = "."),
    format(institution_stats$total_students, big.mark = "."),
    paste0(round(institution_stats$average_conversion_rate * 100, 1), "%"),
    round(institution_stats$applications_per_student, 2)
  )
)

gt(basic_stats) %>%
  tab_header(
    title = paste("Basis Statistieken:", params$school_name),
    subtitle = paste("Schooljaren", params$year)
  ) %>%
  cols_label(
    Metriek = "Metriek",
    Waarde = "Waarde"
  )

```

## 2. Data Kwaliteit Analyse

Deze sectie analyseert de kwaliteit van de data voor `r params$school_name`. We kijken naar postcode validiteit en consistentie van schooljaren. Een goede data kwaliteit is essentieel voor betrouwbare analyses.

```{r}
#| label: data-quality-analysis

# Analyze data quality for this institution
quality_results <- analyze_data_quality(institution_data, by_group = "schooljaar")

# Get quality summary
quality_summary <- get_data_quality_summary(quality_results)

cat("Overall Quality Score:", quality_summary$overall_quality_score, "%\n")

```

### 2.1 Postcode Kwaliteit

```{r}
#| label: postcode-quality

# Show postcode quality table
quality_results$postcode_analysis %>%
  gt() %>%
  tab_header(
    title = "Postcode Kwaliteit per Jaar",
    subtitle = params$school_name
  ) %>%
  cols_label(
    schooljaar = "Schooljaar",
    totaal_aanmeldingen = "Totaal",
    geldige_postcodes = "Geldige Postcodes",
    ongeldige_postcodes = "Ongeldige Postcodes",  
    percentage_ongeldig = "% Ongeldig"
  ) %>%
  fmt_percent(
    columns = percentage_ongeldig,
    decimals = 1,
    scale_values = FALSE
  )

```

```{r}
#| label: postcode-quality-plot
#| fig-height: 4

# Plot postcode quality if there are invalid postcodes
if (nrow(quality_results$postcode_analysis) > 0 && any(quality_results$postcode_analysis$ongeldige_postcodes > 0)) {
  
  quality_results$postcode_analysis %>%
    ggplot(aes(x = factor(schooljaar), y = ongeldige_postcodes)) +
    geom_col(fill = "steelblue", alpha = 0.7) +
    geom_text(aes(label = paste0(percentage_ongeldig, "%")), vjust = -0.5) +
    labs(
      title = paste("Ongeldige Postcodes per Jaar -", params$school_name),
      x = "Schooljaar",
      y = "Aantal Ongeldige Postcodes"
    ) +
    theme_minimal()
    
}

```

### 2.2 Schooljaar Kwaliteit

Hier analyseren we de consistentie tussen het geregistreerde schooljaar en het schooljaar afgeleid uit datums. Dit helpt om data-invoerfouten te identificeren.

```{r}
#| label: schooljaar-quality-preparation

# Create schooljaar_afgeleid based on dates (similar to data_kwaliteit.qmd)
institution_data_with_derived <- institution_data %>%
  mutate(
    # Parse dates using correct column names
    created_date_parsed = lubridate::ymd_hms(createdat),
    start_date_parsed = lubridate::ymd(begindatum),
    
    # Derive schooljaar from created date (October = new school year)
    schooljaar_afgeleid_created = case_when(
      is.na(created_date_parsed) ~ NA_integer_,
      month(created_date_parsed) >= 10 ~ year(created_date_parsed) + 1,
      month(created_date_parsed) < 10 ~ year(created_date_parsed),
      .default = NA_integer_
    ),
    
    # Derive from start date (August = new school year)
    schooljaar_afgeleid_startmoment = case_when(
      is.na(start_date_parsed) ~ NA_integer_,
      month(start_date_parsed) >= 8 ~ year(start_date_parsed),
      month(start_date_parsed) < 8 ~ year(start_date_parsed) - 1,
      .default = NA_integer_
    ),
    
    # Create final derived schooljaar with logic from data_kwaliteit.qmd
    schooljaar_numeric = as.integer(as.character(schooljaar)),
    schooljaar_afgeleid = case_when(
      # If all agree, use original
      schooljaar_numeric == schooljaar_afgeleid_startmoment & 
        schooljaar_numeric == schooljaar_afgeleid_created ~ schooljaar_numeric,
      # If original is 0, use created date derivation
      schooljaar_numeric == 0 ~ schooljaar_afgeleid_created,
      # Early applications in August/September
      schooljaar_numeric == schooljaar_afgeleid_startmoment &
        schooljaar_afgeleid_created == schooljaar_numeric - 1 &
        month(created_date_parsed) %in% c(8,9) ~ schooljaar_numeric,
      # Late applications on October 1st
      schooljaar_numeric == schooljaar_afgeleid_startmoment &
        schooljaar_afgeleid_created == schooljaar_numeric + 1 &
        month(created_date_parsed) == 10 &
        day(created_date_parsed) == 1 ~ schooljaar_numeric,
      # Default to created date derivation
      .default = coalesce(schooljaar_afgeleid_created, schooljaar_numeric)
    )
  )

```

```{r}
#| label: schooljaar-quality-table

# Create detailed schooljaar quality analysis like requested
schooljaar_quality_analysis <- institution_data_with_derived %>%
  # Create combination key for analysis
  mutate(
    combination_key = paste(schooljaar_numeric, schooljaar_afgeleid, sep = "-")
  ) %>%
  group_by(combination_key, schooljaar_numeric, schooljaar_afgeleid) %>%
  summarise(
    aantal_aanmeldingen = n(),
    .groups = "drop"
  ) %>%
  arrange(schooljaar_numeric, schooljaar_afgeleid)

# Calculate totals for percentage calculations
totals_by_original <- schooljaar_quality_analysis %>%
  group_by(schooljaar_numeric) %>%
  summarise(total_original = sum(aantal_aanmeldingen), .groups = "drop")

totals_by_derived <- schooljaar_quality_analysis %>%
  group_by(schooljaar_afgeleid) %>%
  summarise(total_derived = sum(aantal_aanmeldingen), .groups = "drop")

# Create final table with percentages
schooljaar_final_table <- schooljaar_quality_analysis %>%
  left_join(totals_by_original, by = "schooljaar_numeric") %>%
  left_join(totals_by_derived, by = "schooljaar_afgeleid") %>%
  mutate(
    pct_van_origineel_jaar = aantal_aanmeldingen / total_original * 100,
    pct_van_afgeleid_jaar = aantal_aanmeldingen / total_derived * 100
  ) %>%
  select(
    combination_key,
    schooljaar_numeric, 
    schooljaar_afgeleid,
    aantal_aanmeldingen,
    pct_van_origineel_jaar,
    pct_van_afgeleid_jaar
  )

# Show the enhanced table
schooljaar_final_table %>%
  gt() %>%
  tab_header(
    title = "Schooljaar Kwaliteit Analyse",
    subtitle = paste("Gedetailleerde analyse van schooljaar consistentie -", params$school_name)
  ) %>%
  cols_label(
    combination_key = "Combinatie",
    schooljaar_numeric = "Origineel Schooljaar",
    schooljaar_afgeleid = "Afgeleid Schooljaar", 
    aantal_aanmeldingen = "Aantal Aanmeldingen",
    pct_van_origineel_jaar = "% van Origineel Jaar",
    pct_van_afgeleid_jaar = "% van Afgeleid Jaar"
  ) %>%
  fmt_percent(
    columns = c(pct_van_origineel_jaar, pct_van_afgeleid_jaar),
    decimals = 1,
    scale_values = FALSE
  ) %>%
  data_color(
    columns = aantal_aanmeldingen,
    colors = scales::col_numeric(
      palette = c("white", "lightblue"),
      domain = NULL
    )
  ) %>%
  tab_footnote(
    footnote = "% van Origineel Jaar: aandeel van dit jaar in het totaal van het originele schooljaar",
    locations = cells_column_labels(columns = pct_van_origineel_jaar)
  ) %>%
  tab_footnote(
    footnote = "% van Afgeleid Jaar: aandeel van dit jaar in het totaal van het afgeleide schooljaar", 
    locations = cells_column_labels(columns = pct_van_afgeleid_jaar)
  )

cat("\\n**Interpretatie:** Deze tabel toont hoe goed de originele schooljaar registratie overeenkomt met het schooljaar afgeleid uit datums. Een perfecte match (bijv. 2023-2023) met 100% van origineel jaar betekent dat alle aanmeldingen van dat jaar correct geregistreerd zijn.\\n")

```

```{r}
#| label: detailed-schooljaar-comparison

# Show summary of schooljaar quality
discrepancies <- schooljaar_final_table %>%
  filter(schooljaar_numeric != schooljaar_afgeleid) %>%
  nrow()

if (discrepancies > 0) {
  cat("\nðŸ“Š **Samenvatting Schooljaar Kwaliteit:**\n")
  cat("- Aantal combinaties met afwijkingen:", discrepancies, "\n")
  cat("- Totaal aantal combinaties:", nrow(schooljaar_final_table), "\n")
  cat("- Percentage perfecte matches:", round((nrow(schooljaar_final_table) - discrepancies) / nrow(schooljaar_final_table) * 100, 1), "%\n\n")
  
  cat("**Aanbeveling:** Onderzoek de oorzaken van schooljaar discrepanties om data kwaliteit te verbeteren.\n")
} else {
  cat("âœ… **Uitstekende Data Kwaliteit**: Alle schooljaren komen perfect overeen - geen aanpassingen nodig.\n")
}

```

## 3. Conversie Overzicht

Deze sectie geeft een overzicht van de algemene conversie van aanmeldingen naar inschrijvingen voor `r params$school_name`. We kijken naar de basisstatistieken die de effectiviteit van het aanmeldingsproces weergeven.

```{r}
#| label: conversion-overview

# Create conversion overview
conversion_summary <- data.frame(
  Metriek = c(
    "Totaal aanmeldingen (gegroepeerd)", 
    "Unieke studenten",
    "Totaal ingeschreven studenten",
    "Gemiddelde conversie ratio"
  ),
  Waarde = c(
    format(nrow(grouped_institution), big.mark = "."),
    format(institution_stats$total_students, big.mark = "."),
    format(sum(grouped_institution$is_enrolled, na.rm = TRUE), big.mark = "."),
    paste0(round(institution_stats$average_conversion_rate * 100, 1), "%")
  ),
  Toelichting = c(
    "Aantal gegroepeerde aanmeldingen in analyse",
    "Aantal unieke studenten die zich hebben aangemeld", 
    "Aantal studenten dat daadwerkelijk is ingeschreven",
    "Percentage van studenten dat zich inschrijft na aanmelding"
  )
)

conversion_summary %>%
  gt() %>%
  tab_header(
    title = "Conversie Overzicht",
    subtitle = paste("Kernstatistieken aanmeldingsproces -", params$school_name)
  ) %>%
  cols_label(
    Metriek = "Metriek",
    Waarde = "Waarde",
    Toelichting = "Toelichting"
  ) %>%
  cols_width(
    Toelichting ~ px(300)
  )

cat("\\n**Interpretatie:** Een hoge conversie ratio duidt op een effectief aanmeldingsproces waarbij studenten die zich aanmelden ook daadwerkelijk inschrijven. Dit kan wijzen op goede voorlichting, aantrekkelijke opleidingen, of een efficiÃ«nt aanmeldingsproces.\\n")

```

## 4. Analyse van Aanmeldingspatronen

Deze sectie geeft een diepgaande analyse van hoe studenten zich aanmelden bij `r params$school_name`. We analyseren zowel studenten met Ã©Ã©n aanmelding als studenten met meerdere aanmeldingen om patronen en trends te identificeren.

### 4.1 Algemene Patronen Meervoudige Aanmeldingen

Deze analyse is gebaseerd op **alle instellingen** in de dataset, om context te geven voor de prestaties van `r params$school_name`.

```{r}
#| label: general-multiple-applications-overview

# Gebruik de eerder berekende analyse van het volledige dataset
if ("conversion_by_pattern" %in% names(multiple_applications_analysis)) {
  
  # Show general patterns across all institutions
  general_pattern_data <- multiple_applications_analysis$conversion_by_pattern %>%
    mutate(
      pattern_clean = case_when(
        str_detect(pattern_type, "Ã©Ã©n aanmelding|single") ~ "Enkele aanmelding",
        str_detect(pattern_type, "binnen.*instelling") ~ "Meerdere binnen instelling",
        str_detect(pattern_type, "tussen.*instelling") ~ "Meerdere tussen instellingen",
        str_detect(pattern_type, "binnen.*tussen") ~ "Meerdere binnen Ã©n tussen",
        TRUE ~ pattern_type
      )
    ) %>%
    arrange(desc(total))
  
  # Show general conversion table for context
  general_pattern_data %>%
    select(pattern_clean, total, enrolled, conversion_rate) %>%
    gt() %>%
    tab_header(
      title = "Algemene Conversie per Aanmeldingspatroon",
      subtitle = "Gegevens van alle instellingen in de dataset voor vergelijking"
    ) %>%
    cols_label(
      pattern_clean = "Aanmeldingspatroon",
      total = "Totaal Studenten",
      enrolled = "Aantal Ingeschreven", 
      conversion_rate = "Conversie %"
    ) %>%
    fmt_percent(
      columns = conversion_rate,
      decimals = 1,
      scale_values = FALSE
    ) %>%
    data_color(
      columns = conversion_rate,
      colors = scales::col_numeric(
        palette = c("white", "darkgreen"),
        domain = NULL
      )
    )
    
} else {
  cat("Algemene analyse van aanmeldingspatronen niet mogelijk - onvoldoende data.")
}

```

### 4.2 Institutie-Specifieke Patronen voor `r params$school_name`

Nu kijken we specifiek naar hoe studenten zich gedragen bij `r params$school_name`.

```{r}
#| label: institution-specific-patterns

# Analyze multiple application patterns for this specific institution
institution_multiple_patterns <- analyze_multiple_applications(grouped_institution)

# Create a flowchart-style visualization of application patterns
if ("conversion_by_pattern" %in% names(institution_multiple_patterns)) {
  
  # Prepare data for flowchart visualization
  pattern_data <- institution_multiple_patterns$conversion_by_pattern %>%
    mutate(
      # Ensure we have all categories including single applications
      pattern_clean = case_when(
        str_detect(pattern_type, "Ã©Ã©n aanmelding|single") ~ "Enkele aanmelding",
        str_detect(pattern_type, "binnen.*instelling") ~ "Meerdere binnen instelling",
        str_detect(pattern_type, "tussen.*instelling") ~ "Meerdere tussen instellingen",
        str_detect(pattern_type, "binnen.*tussen") ~ "Meerdere binnen Ã©n tussen",
        TRUE ~ pattern_type
      )
    ) %>%
    arrange(desc(total))
  
  # Show the enhanced conversion table for this institution
  pattern_data %>%
    select(pattern_clean, total, enrolled, conversion_rate) %>%
    gt() %>%
    tab_header(
      title = paste("Conversie per Aanmeldingspatroon -", params$school_name),
      subtitle = "Instelling-specifieke aanmeldingsstrategieÃ«n"
    ) %>%
    cols_label(
      pattern_clean = "Aanmeldingspatroon",
      total = "Totaal Studenten",
      enrolled = "Aantal Ingeschreven", 
      conversion_rate = "Conversie %"
    ) %>%
    fmt_percent(
      columns = conversion_rate,
      decimals = 1,
      scale_values = FALSE
    ) %>%
    data_color(
      columns = conversion_rate,
      colors = scales::col_numeric(
        palette = c("white", "darkgreen"),
        domain = NULL
      )
    )
    
} else {
  cat("Analyse van aanmeldingspatronen niet mogelijk - onvoldoende data voor", params$school_name)
}

```

### 4.3 Visualisatie Aanmeldingspatronen

De onderstaande visualisaties tonen de verschillende aanmeldingsstrategieÃ«n van studenten en hun effectiviteit. We vergelijken het totale volume van elke strategie met de uiteindelijke inschrijvingen om te zien welke benaderingen het meest succesvol zijn.

**Waarom is dit belangrijk?** Door te begrijpen hoe verschillende aanmeldingspatronen presteren, kan `r params$school_name` haar communicatie en begeleiding aanpassen aan verschillende types studenten.

```{r}
#| label: application-patterns-flowchart
#| fig-height: 8

# Create a comprehensive visualization showing the flow from applications to enrollment
if (exists("pattern_data")) {
  
  # Create bar chart showing volumes and conversion
  p1 <- pattern_data %>%
    select(pattern_clean, total, enrolled) %>%
    pivot_longer(cols = c(total, enrolled), names_to = "type", values_to = "count") %>%
    mutate(
      type = ifelse(type == "total", "Totaal Studenten", "Ingeschreven"),
      pattern_clean = fct_reorder(pattern_clean, count, .fun = max)
    ) %>%
    ggplot(aes(x = pattern_clean, y = count, fill = type)) +
    geom_col(position = "dodge", alpha = 0.8) +
    scale_fill_manual(values = c("Totaal Studenten" = "steelblue", "Ingeschreven" = "darkgreen")) +
    coord_flip() +
    labs(
      title = "Volume per Aanmeldingspatroon",
      subtitle = "Vergelijking tussen totaal aantal studenten en ingeschrevenen",
      x = "Aanmeldingspatroon",
      y = "Aantal Studenten",
      fill = "Type"
    ) +
    theme_minimal() +
    theme(legend.position = "bottom")
  
  # Create conversion rate visualization
  p2 <- pattern_data %>%
    ggplot(aes(x = fct_reorder(pattern_clean, conversion_rate), y = conversion_rate)) +
    geom_col(fill = "darkgreen", alpha = 0.7) +
    geom_text(aes(label = paste0(round(conversion_rate, 1), "%")), 
              hjust = -0.1, size = 3) +
    coord_flip() +
    scale_y_continuous(limits = c(0, max(pattern_data$conversion_rate) * 1.2)) +
    labs(
      title = "Conversiepercentage per Aanmeldingspatroon",
      subtitle = "Hoe succesvol zijn verschillende aanmeldingsstrategieÃ«n?",
      x = "Aanmeldingspatroon",
      y = "Conversiepercentage (%)"
    ) +
    theme_minimal()
  
  # Display both plots with additional context
  print(p1)
  
  cat("\n**Interpretatie Volume Chart:** De eerste grafiek toont het totale aantal studenten per aanmeldingspatroon (blauw) versus het aantal dat zich daadwerkelijk inschrijft (groen). Dit geeft inzicht in de absolute aantallen.\n\n")
  
  print(p2)
  
  cat("\n**Interpretatie Conversie Chart:** De tweede grafiek toont het conversiepercentage per patroon. Een hoger percentage betekent dat die aanmeldingsstrategie effectiever is in het omzetten van interesse naar daadwerkelijke inschrijving.\n")
  
} else {
  cat("âš ï¸ Visualisatie niet mogelijk - onvoldoende data voor aanmeldingspatronen.")
}

```

### 4.4 Verdeling Aantal Aanmeldingen

Deze analyse toont hoe studenten zich gedragen qua aantal aanmeldingen. Dit is waardevol om te begrijpen:
- **Volume Perspectief**: Hoeveel studenten kiezen voor elke strategie?
- **Timing Inzichten**: Veranderen patronen tussen schooljaren?
- **Strategische Planning**: Welke groepen studenten hebben extra ondersteuning nodig?

**Algemeen Patroon**: De meeste studenten doen Ã©Ã©n aanmelding, maar een significante groep doet meerdere aanmeldingen - deze laatste groep heeft vaak andere behoeften en gedrag.

```{r}
#| label: application-count-distribution
#| fig-height: 6

# Plot distribution of application counts for this institution
if ("application_count_distribution" %in% names(institution_multiple_patterns)) {
  
  institution_multiple_patterns$application_count_distribution %>%
    filter(applications_total_number <= 6) %>%
    ggplot(aes(x = students_pct, 
               y = reorder(factor(applications_total_number), -as.numeric(applications_total_number)),
               fill = factor(schooljaar))) +
    geom_col(position = "dodge") +
    geom_text(aes(label = paste0(round(students_pct, 1), "%")), 
              position = position_dodge(width = 0.9),
              hjust = -0.2, size = 3) +
    scale_fill_brewer(palette = "Set1") +
    scale_x_continuous(limits = c(0, max(institution_multiple_patterns$application_count_distribution$students_pct) * 1.2)) +
    theme_minimal() +
    labs(
      title = paste("Verdeling Aantal Aanmeldingen per Student -", params$school_name),
      subtitle = "Percentage studenten per aantal aanmeldingen",
      x = "Percentage Studenten (%)",
      y = "Aantal Aanmeldingen per Student",
      fill = "Schooljaar"
    )
    
} else {
  cat("Data voor aanmeldingsverdeling niet beschikbaar.")
}

```

```{r}
#| label: conversion-by-application-count
#| fig-height: 6

# Plot conversion rate by application count for this institution
if ("conversion_by_count" %in% names(institution_multiple_patterns)) {
  institution_multiple_patterns$conversion_by_count %>%
    filter(applications_total_number <= 6) %>%
    ggplot(aes(x = application_conversion_rate,
               y = reorder(factor(applications_total_number), -as.numeric(applications_total_number)),
               fill = factor(schooljaar))) +
    geom_col(position = "dodge") +
    geom_text(aes(label = paste0(round(application_conversion_rate, 1), "%")), 
              position = position_dodge(width = 0.9),
              hjust = -0.2, size = 3) +
    scale_fill_brewer(palette = "Set1") +
    theme_minimal() +
    labs(
      title = paste("Conversie per Aanmelding naar Aantal Aanmeldingen -", params$school_name),
      subtitle = "Percentage van aanmeldingen dat resulteert in inschrijving",
      y = "Aantal Aanmeldingen per Student",
      x = "Conversie per Aanmelding (%)",
      fill = "Schooljaar"
    )
} else {
  cat("Data voor conversie per aantal aanmeldingen niet beschikbaar.")
}

```

## 5. Tijdsanalyse van Aanmeldingen

Deze sectie analyseert wanneer studenten zich aanmelden gedurende het schooljaar. Dit helpt om seizoenspatronen te identificeren en marketingactiviteiten beter te timen. Het academisch jaar loopt van oktober tot september.

```{r}
#| label: timing-analysis

# Analyze application timing patterns for this institution
timing_analysis <- analyze_application_timing(institution_data)

# Prepare timing data for analysis
cat("Analyse van aanmeldingspatronen per maand voor", params$school_name, "\n")
cat("Totaal aantal maanden met data:", nrow(timing_analysis$monthly_stats), "\n")
cat("Jaar(jaren) in analyse:", paste(unique(timing_analysis$monthly_stats$schooljaar), collapse = ", "), "\n\n")

```

### 5.1 Maandelijkse Aanmeldingspatronen

**Waarom Timing Belangrijk Is**: Het begrijpen van aanmeldingspieken helpt bij:
- **Resource Planning**: Wanneer zijn er meer medewerkers nodig?
- **Marketing Timing**: Wanneer moeten campagnes worden uitgevoerd?
- **Capaciteitsplanning**: Wanneer kunnen we de meeste interesse verwachten?

De grafiek toont duidelijke seizoenspatronen in aanmeldingen. Meestal zijn er piekperiodes in het voorjaar (maart-mei) en een tweede golf in de zomer. Let op verschillen tussen schooljaren - dit kan wijzen op veranderende studentgedrag of externe factoren.

```{r}
#| label: monthly-applications-plot
#| fig-height: 5

# Plot monthly application patterns
if (nrow(timing_analysis$monthly_stats) > 0) {
  
  timing_analysis$monthly_stats %>%
    ggplot(aes(x = academic_month, y = applications, 
               colour = factor(schooljaar), group = factor(schooljaar))) +
    geom_line(size = 1.2) +
    geom_point(size = 2.5) +
    scale_x_continuous(breaks = 1:12, labels = timing_analysis$month_labels) +
    scale_colour_brewer(palette = "Set1") +
    theme_minimal() +
    labs(
      title = paste("Maandelijkse Aanmeldingen -", params$school_name),
      subtitle = "Academisch jaar: Oktober (maand 1) t/m September (maand 12)",
      x = "Maand (Academisch Jaar)",
      y = "Aantal Aanmeldingen",
      colour = "Schooljaar"
    ) +
    theme(legend.position = "bottom")
    
} else {
  cat("Onvoldoende data voor maandelijkse analyse.")
}

```

### 5.2 Maandelijkse Conversiepatronen

**Strategische Waarde van Timing**: Deze analyse onthult:
- **Early Bird Effect**: Converteren vroege aanmelders beter?
- **Seizoensinvloeden**: Zijn er maanden met structureel lagere conversie?
- **Procesoptimalisatie**: Wanneer moeten extra inspanningen worden geleverd?

**Hypothese**: Vroege aanmelders hebben vaak een hogere conversiekans omdat zij meer gemotiveerd zijn en meer tijd hebben voor de beslissing. Late aanmelders kunnen onder tijdsdruk staan of tweede keuzes maken.

```{r}
#| label: monthly-conversion-plot
#| fig-height: 5

# Plot monthly conversion patterns
if (nrow(timing_analysis$monthly_stats) > 0) {
  
  timing_analysis$monthly_stats %>%
    filter(!is.na(conversion_rate)) %>%
    ggplot(aes(x = academic_month, y = conversion_rate,
               colour = factor(schooljaar), group = factor(schooljaar))) +
    geom_line(size = 1.2) +
    geom_point(size = 2.5) +
    scale_x_continuous(breaks = 1:12, labels = timing_analysis$month_labels) +
    scale_colour_brewer(palette = "Set1") +
    theme_minimal() +
    labs(
      title = paste("Maandelijkse Conversiepercentages -", params$school_name),
      subtitle = "Hoe beÃ¯nvloedt het tijdstip van aanmelding de conversiekans?",
      x = "Maand (Academisch Jaar)", 
      y = "Conversiepercentage (%)",
      colour = "Schooljaar"
    ) +
    theme(legend.position = "bottom")
    
} else {
  cat("Onvoldoende data voor conversie-analyse per maand.")
}

```

## 6. Status Transitie Analyse

Deze sectie analyseert hoe de status van aanmeldingen verandert gedurende het schooljaar. We volgen de ontwikkeling van aanmeldingen van indiening tot uiteindelijke beslissing (inschrijving, afwijzing, of intrekking). De analyse is cumulatief: studenten behouden hun status tot deze verandert.

```{r}
#| label: status-transitions-analysis

status_analysis <- analyze_status_transitions(institution_data, target_year = params$year)

cat("Analyse van status overgangen voor schooljaar", params$year, "\n")

```

```{r}
#| label: status-transitions-plot
#| fig-height: 6

# Plot status transitions over time
if (nrow(status_analysis$result) > 0) {
  
  # Define colors for different statuses
  status_colors <- c(
    "Submitted" = "#a9cce3",
    "Received" = "#2980b9", 
    "Offered" = "#1a5276",
    "Enrolled" = "darkgreen",
    "Rejected" = "#e74c3c",
    "Withdrawn" = "#f39c12",
    "Other" = "#95a5a6"
  )
  
  # Plot stacked area chart
  ggplot(status_analysis$result, 
       aes(x = academic_week, y = count, 
           fill = status_proper_case, group = status_proper_case)) +
    geom_area(position = "stack", alpha = 0.8) +
    scale_fill_manual(values = status_colors) +
    theme_minimal() +
    labs(title = "Aantal Aanmeldingen per Status per Week",
         subtitle = "Schooljaar 2024",
         x = "Week (academisch jaar)",
         y = "Aantal Aanmeldingen",
         fill = "Status") +
    scale_x_continuous(
        breaks = status_analysis$month_start_weeks$start_week,
        labels = status_analysis$month_labels[status_analysis$month_start_weeks$academic_month],
        expand = c(0, 0)
    ) +
    scale_y_continuous(labels = comma,
                       expand = c(0, 0)) +
    theme(
        panel.grid.minor = element_blank(),
        legend.position = "bottom"
    )
    
} else {
  cat("Onvoldoende data voor status transitie analyse.")
}

```

## 7. Geografische Analyse Studentenherkomst

Deze sectie toont waar studenten vandaan komen die zich inschrijven bij **`r params$school_name`** en hoe dit zich verhoudt tot de totale markt per postcode.

```{r}
#| label: geographic-market-analysis

institution_data <- institution_data %>% mutate(postcodecijfers = as.numeric(postcodecijfers))

# Calculate postcode distribution for this institution
postcode_data <- calculate_market_share_by_postcode(
    institution_data, 
    institution_name = params$school_name,
    year = params$year
)

# Summary statistics
postcode_summary <- postcode_data %>%
    group_by(schooljaar) %>%
    summarise(
        postcodes_with_students = sum(institution_students > 0),
        total_postcodes = n(),
        avg_postcode_percentage = mean(postcode_percentage, na.rm = TRUE),
        max_postcode_percentage = max(postcode_percentage, na.rm = TRUE),
        total_students = sum(institution_students),
        .groups = "drop"
    )

cat("Geografische analyse voor", params$school_name, "\n")
cat("Aantal postcodes in analyse:", nrow(postcode_data), "\n")
cat("Schooljaar:", paste(unique(postcode_data$schooljaar), collapse = ", "), "\n")

```

```{r}
#| label: market-share-summary-table

# Show postcode distribution summary
postcode_summary %>%
    gt() %>%
    tab_header(
        title = paste("Postcode Verdeling Samenvatting:", params$school_name),
        subtitle = "Geografische spreiding per schooljaar"
    ) %>%
    cols_label(
        schooljaar = "Schooljaar",
        postcodes_with_students = "Postcodes met studenten",
        total_postcodes = "Totaal postcodes in analyse",
        avg_postcode_percentage = "Gemiddeld percentage (%)",
        max_postcode_percentage = "Maximaal percentage (%)",
        total_students = "Totaal studenten"
    ) %>%
    fmt_number(
        columns = c(postcodes_with_students, total_postcodes, total_students),
        decimals = 0
    ) %>%
    fmt_number(
        columns = c(avg_postcode_percentage, max_postcode_percentage),
        decimals = 1
    )

```

### Postcode Verdeling Kaart 2023

```{r}
#| label: geographic-map-2023

# Create map for 2023
if (nrow(postcode_data) > 0 && file.exists("data/reference/cbs_pc4_2024_v1.gpkg")) {
    map_2023 <- create_market_share_map(
        postcode_data = postcode_data,
        geo_data_path = "data/reference/cbs_pc4_2024_v1.gpkg",
        target_year = 2023,
        institution_name = params$school_name
    )
    map_2023
} else {
    cat("Geen geografische data beschikbaar voor kaart 2023.\n")
}

```

### Postcode Verdeling Kaart 2024

```{r}
#| label: geographic-map-2024

# Create map for 2024
if (nrow(postcode_data) > 0 && file.exists("data/reference/cbs_pc4_2024_v1.gpkg")) {
    map_2024 <- create_market_share_map(
        postcode_data = postcode_data,
        geo_data_path = "data/reference/cbs_pc4_2024_v1.gpkg",
        target_year = 2024,
        institution_name = params$school_name
    )
    map_2024
} else {
    cat("Geen geografische data beschikbaar voor kaart 2024.\n")
}

```

### Top 10 Postcodes 2023

```{r}
#| label: top-postcodes-2023-table

# Find top postcodes for 2023
if (nrow(postcode_data) > 0) {
    top_postcodes_2023 <- postcode_data %>%
        filter(institution_students > 0, schooljaar == 2023) %>%
        arrange(desc(institution_students)) %>%
        head(10) %>%
        select(postcode_4, institution_students, postcode_percentage)
    
    if (nrow(top_postcodes_2023) > 0) {
        # Display top postcodes table for 2023
        top_postcodes_2023 %>%
            gt() %>%
            tab_header(
                title = paste("Top 10 Postcodes 2023 voor", params$school_name),
                subtitle = "Gerangschikt op aantal studenten"
            ) %>%
            cols_label(
                postcode_4 = "Postcode",
                institution_students = "Studenten",
                postcode_percentage = "Percentage (%)"
            ) %>%
            fmt_number(
                columns = institution_students,
                decimals = 0
            ) %>%
            fmt_number(
                columns = postcode_percentage,
                decimals = 1
            ) %>%
            tab_style(
                style = cell_fill(color = "#f0f8ff"),
                locations = cells_body(rows = postcode_percentage > 5)
            )
    } else {
        cat("Geen postcodes met studenten gevonden voor 2023")
    }
} else {
    cat("Geen data beschikbaar voor 2023")
}
```

### Top 10 Postcodes 2024

```{r}
#| label: top-postcodes-2024-table

# Find top postcodes for 2024
if (nrow(postcode_data) > 0) {
    top_postcodes_2024 <- postcode_data %>%
        filter(institution_students > 0, schooljaar == 2024) %>%
        arrange(desc(institution_students)) %>%
        head(10) %>%
        select(postcode_4, institution_students, postcode_percentage)
    
    if (nrow(top_postcodes_2024) > 0) {
        # Display top postcodes table for 2024
        top_postcodes_2024 %>%
            gt() %>%
            tab_header(
                title = paste("Top 10 Postcodes 2024 voor", params$school_name),
                subtitle = "Gerangschikt op aantal studenten"
            ) %>%
            cols_label(
                postcode_4 = "Postcode",
                institution_students = "Studenten",
                postcode_percentage = "Percentage (%)"
            ) %>%
            fmt_number(
                columns = institution_students,
                decimals = 0
            ) %>%
            fmt_number(
                columns = postcode_percentage,
                decimals = 1
            ) %>%
            tab_style(
                style = cell_fill(color = "#fff2e6"),
                locations = cells_body(rows = postcode_percentage > 5)
            )
    } else {
        cat("Geen postcodes met studenten gevonden voor 2024")
    }
} else {
    cat("Geen data beschikbaar voor 2024")
}

```

```{r}
#| label: market-share-vs-population

# Analyze market share vs population density
if (nrow(postcode_data) > 0 && file.exists("data/reference/cbs_pc4_2024_v1.gpkg")) {
    
    # Load geographic data with population
    postal_geo <- sf::st_read("data/reference/cbs_pc4_2024_v1.gpkg", quiet = TRUE)
    
    # Join market share with population data for most recent year
    recent_year <- max(postcode_data$schooljaar)
    market_population <- postcode_data %>%
        filter(schooljaar == recent_year) %>%
        mutate(postcode = as.numeric(postcode_4)) %>%
        left_join(
            postal_geo %>% sf::st_drop_geometry() %>% select(postcode, aantal_inwoners),
            by = "postcode"
        ) %>%
        filter(!is.na(aantal_inwoners), aantal_inwoners > 0, institution_students > 0)
    
    if (nrow(market_population) > 10) {
        # Create scatter plot of market share vs population
        market_population %>%
            ggplot(aes(x = aantal_inwoners, y = postcode_percentage)) +
            geom_point(aes(size = institution_students), alpha = 0.6, color = "steelblue") +
            geom_smooth(method = "loess", se = TRUE, color = "red", alpha = 0.3) +
            scale_x_log10(labels = scales::comma) +
            scale_size_continuous(name = "Studenten", range = c(2, 10)) +
            theme_minimal() +
            labs(
                title = paste("Percentage vs Bevolkingsdichtheid -", params$school_name),
                subtitle = paste("Schooljaar", recent_year, "- Grootte punt = aantal studenten"),
                x = "Aantal Inwoners per Postcode (log schaal)",
                y = "Percentage (%)",
                caption = "Trend lijn toont gemiddelde relatie tussen bevolking en percentage"
            )
        
        cat("\n### Analyse Percentage vs Bevolking\n\n")
        
        # Calculate correlation
        correlation <- cor(log10(market_population$aantal_inwoners), 
                          market_population$postcode_percentage, 
                          use = "complete.obs")
        
        cat("**Correlatie tussen log(bevolking) en percentage:**", round(correlation, 3), "\n\n")
        
        # Find outliers - high market share in small populations
        high_efficiency <- market_population %>%
            filter(postcode_percentage > 25, aantal_inwoners < 5000) %>%
            arrange(desc(postcode_percentage)) %>%
            head(5)
        
        if (nrow(high_efficiency) > 0) {
            cat("**Hoog percentage in kleine gebieden:**\n")
            for (i in 1:nrow(high_efficiency)) {
                cat("-", high_efficiency$postcode_4[i], 
                    "(", high_efficiency$postcode_percentage[i], "% percentage,", 
                    scales::comma(high_efficiency$aantal_inwoners[i]), "inwoners)\n")
            }
        }
        
    } else {
        cat("Onvoldoende data voor percentage vs bevolking analyse.\n")
    }
} else {
    cat("Geografische data niet beschikbaar voor populatie analyse.\n")
}

```

```{r}
#| label: geographic-insights

# Generate geographic insights
cat("### Geografische Inzichten\n\n")

if (nrow(postcode_data) > 0) {
    # Calculate key metrics
    total_postcodes_with_students <- sum(postcode_data$institution_students > 0)
    high_share_postcodes <- sum(postcode_data$postcode_percentage > 10, na.rm = TRUE)
    dominant_postcodes <- sum(postcode_data$postcode_percentage > 20, na.rm = TRUE)
    
    # Most recent year stats
    recent_year <- max(postcode_data$schooljaar)
    recent_data <- postcode_data %>% filter(schooljaar == recent_year)
    
    cat("**Geografische Spreiding (", recent_year, "):**\n")
    cat("- Postcodes met studenten:", sum(recent_data$institution_students > 0), "\n")
    cat("- Postcodes met >10% percentage:", sum(recent_data$postcode_percentage > 10, na.rm = TRUE), "\n")
    cat("- Postcodes met >20% percentage:", sum(recent_data$postcode_percentage > 20, na.rm = TRUE), "\n")
    
    # Top postcode
    top_postcode <- recent_data %>%
        filter(institution_students == max(institution_students)) %>%
        slice(1)
    
    if (nrow(top_postcode) > 0) {
        cat("- Belangrijkste postcode:", top_postcode$postcode_4, 
            "(", top_postcode$institution_students, "studenten,", 
            round(top_postcode$postcode_percentage, 1), "% van instelling)\n")
    }
    
    cat("\n**Strategische Kansen:**\n")
    
    # Find postcodes with low representation relative to student count
    low_representation <- recent_data %>%
        filter(institution_students >= 2, postcode_percentage < 5) %>%
        arrange(desc(institution_students)) %>%
        head(5)
    
    if (nrow(low_representation) > 0) {
        cat("- Postcodes met relatief weinig studenten (< 5% van totaal):\n")
        for (i in 1:nrow(low_representation)) {
            cat("  -", low_representation$postcode_4[i], 
                "(", low_representation$institution_students[i], "studenten,", 
                round(low_representation$postcode_percentage[i], 1), "% van instelling)\n")
        }
    }
} else {
    cat("Onvoldoende data voor geografische analyse.\n")
}

```

## Conclusies en Aanbevelingen

Op basis van deze analyse kunnen we het volgende concluderen voor **`r params$school_name`**:

```{r}
#| label: conclusions
#| results: asis

# Generate conclusions based on data
conclusions <- c()

# Data quality conclusion
if (quality_summary$overall_quality_score >= 80) {
  conclusions <- c(conclusions, "âœ… **Data Kwaliteit**: Goed (score: " , quality_summary$overall_quality_score, "%)")
} else {
  conclusions <- c(conclusions, "âš ï¸ **Data Kwaliteit**: Aandacht vereist (score: " , quality_summary$overall_quality_score, "%)")
}

# Conversion rate conclusion
conversion_rate <- institution_stats$average_conversion_rate * 100
if (conversion_rate > 70) {
  conclusions <- c(conclusions, paste0("âœ… **Conversie**: Hoog conversiepercentage (", round(conversion_rate, 1), "%) - goede aantrekkingskracht"))
} else if (conversion_rate > 50) {
  conclusions <- c(conclusions, paste0("âž¡ï¸ **Conversie**: Gemiddeld conversiepercentage (", round(conversion_rate, 1), "%) - ruimte voor verbetering"))
} else {
  conclusions <- c(conclusions, paste0("âš ï¸ **Conversie**: Laag conversiepercentage (", round(conversion_rate, 1), "%) - analyse van oorzaken nodig"))
}

# Volume conclusion  
student_count <- institution_stats$total_students
if (student_count > 500) {
  conclusions <- c(conclusions, "ðŸ“Š **Volume**: Grote instelling met voldoende data voor analyse")
} else if (student_count > 100) {
  conclusions <- c(conclusions, "ðŸ“Š **Volume**: Middelgrote instelling")
} else {
  conclusions <- c(conclusions, "ðŸ“Š **Volume**: Kleine instelling - voorzichtigheid met interpretatie")
}

# Multiple applications conclusion
if (exists("institution_multiple_patterns") && "conversion_by_pattern" %in% names(institution_multiple_patterns)) {
  single_app_pct <- institution_multiple_patterns$conversion_by_pattern %>%
    filter(pattern_type == "Slechts 1 aanmelding") %>%
    pull(conversion_rate) %>%
    mean()
  
  multiple_app_pct <- institution_multiple_patterns$conversion_by_pattern %>%
    filter(pattern_type != "Slechts 1 aanmelding") %>%
    pull(conversion_rate) %>%
    mean()
  
  if (!is.na(multiple_app_pct) && multiple_app_pct > single_app_pct) {
    conclusions <- c(conclusions, "ðŸ”„ **Meervoudige Aanmeldingen**: Studenten met meerdere aanmeldingen converteren beter")
  }
}

# Print conclusions
for (conclusion in conclusions) {
  cat("- ", conclusion, "\n")
}

```

### Vervolgstappen

1. **Data Kwaliteit**: `r if(quality_summary$overall_quality_score < 80) "Verbeter data invoer processen" else "Handhaaf huidige kwaliteit"`
2. **Conversie Optimalisatie**: Analyseer succesfactoren en vergelijk met algemene patronen uit de dataset
3. **Meervoudige Aanmeldingen**: `r if(exists("institution_multiple_patterns")) "Ontwikkel gerichte begeleiding voor studenten met meerdere aanmeldingen" else "Analyseer aanmeldingspatronen"`
4. **Timing Optimalisatie**: Pas marketingcampagnes aan op basis van seizoenspatronen in aanmeldingen
5. **Status Transitie**: Optimaliseer administratieve processen voor snellere statuswijzigingen
6. **Monitoring**: Implementeer maandelijkse monitoring van deze KPI's

---
*Rapport gegenereerd op `r Sys.Date()` met geautomatiseerde pipeline*
