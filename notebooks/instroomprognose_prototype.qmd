---
subtitle: "Eerste inzichten in aanmeldingsgegevens"
author: "Corneel den Hartogh"
affiliation: "CEDA - Npuls"
date: "`r format(Sys.time(), '%d %B %Y')`"
format: 
  html:
    toc: true
    toc-title: Inhoudsopgave
    code-fold: true
    code-summary: "Laat code zien"
  pdf:
    toc: true
    toc-title: Inhoudsopgave
    #number-sections: true
    #colorlinks: true
    echo: false
execute:
  cache: true
  freeze: auto
  include: true
  warning: false

---

```{r}
#| label: setup
#| cache: false
#| output: false
#| include: false
#| freeze: false

# Load required libraries
source("utils/00_setup.R")

# Set config, change to cambo to run with real data from cambo
Sys.setenv(R_CONFIG_ACTIVE = "default")

```

---
title: "Instroom exploratie `r config::get('name')`"
---


## 1. Data inladen & prepareren

We laden de data in.

```{r}
#| label: load-data
#| freeze: true
#| cache: false

applications_filepath <- file.path(config::get("data_base_dir"),
                                   config::get("applications_filename"))

applications <- safe_read_csv(applications_filepath, 
                      delim = ",",
                      col_types = cols(.default = col_guess()))

# Load reference data
brin <- read_excel("data/reference/BRIN.xlsx")
programmes <- read_excel("data/reference/Opleiding_dimensie.xlsx")


```

We voegen de referentie data toe aan het bronbestand.

```{r}
#| label: enrich-data
#| cache: false
#| freeze: false
# Join with reference data
applications_enriched <- applications %>%
    # Convert opleidingcode to integer for joining (drops a small % of non-numeric values)
    mutate(opleidingcode = as.integer(opleidingcode)) %>%
    left_join(programmes, by = c("opleidingcode" = "Opleidingcode")) %>%
    left_join(brin, by = c("instellingserkenningscode" = "BRIN"))

```

## 2. Aanmeldingsoverzicht

Hier creëren we KPI's en visualisaties die ons hoofddashboard zullen vormen. Door trends over de jaren heen te analyseren, kunnen we inzicht krijgen in het aanmeldingsvolume en conversiepercentages. Dit is essentieel om te begrijpen of er specifieke jaren zijn met afwijkende patronen.

```{r}
#| label: dashboard-metrics

# Berekenen van hoofdmetrieken per jaar
yearly_metrics <- applications_enriched %>%
  group_by(schooljaar) %>%
  summarise(
    total_applications = n(),
    unique_students = n_distinct(bsnhash),
    conversion_rate = mean(status == "ENROLLED", na.rm = TRUE) * 100,
    .groups = "drop"
  ) %>%
  arrange(schooljaar)

# Toon metrieken in een mooie tabel met gt i.p.v. knitr
yearly_metrics %>%
  gt() %>%
  tab_header(
    title = "Jaarlijkse Aanmeldingsstatistieken"
  ) %>%
  cols_label(
    schooljaar = "Schooljaar",
    total_applications = "Totaal aantal rijen",
    unique_students = "Unieke Studenten"#,
    #conversion_rate = "Conversiepercentage (%)"
  ) %>%
  fmt_number(
    columns = c(total_applications, unique_students),
    decimals = 0,
    use_seps = TRUE
  ) %>%
  # fmt_percent(
  #   columns = conversion_rate,
  #   decimals = 1,
  #   scale_values = FALSE
  # ) %>%
  tab_style(
    style = cell_fill(color = "#f5f5f5"),
    locations = cells_body(rows = schooljaar %in% c(2023, 2024))
  )
```

We zien hierboven duidelijke verschillen in het aantal aanmeldingen per jaar. Het is opvallend dat jaar 0 (wat een datakwaliteitsprobleem kan aanduiden) en de jaren 2023 en 2024 aanzienlijk meer aanmeldingen bevatten dan andere jaren. Laten we deze data visualiseren om de verschillen nog duidelijker te maken.

```{r}
#| label: yearly-trend-plot

# Visualisatie van trends
yearly_metrics %>%
  pivot_longer(cols = c(total_applications, unique_students), 
               names_to = "metric", 
               values_to = "value") %>%
  mutate(metric = if_else(metric == "total_applications", 
                         "Aantal Statusveranderingen", 
                         "Unieke Studenten")) %>%
  ggplot(aes(x = factor(schooljaar), y = value, group = metric, color = metric), fill = c("Aantal Statusveranderingen" = "#1976D2", "Unieke Studenten" = "#FF9800")) +
  geom_line() +
  geom_point(size = 2) +
  theme_minimal() +
  labs(title = "Trend van Aanmeldingen per Jaar",
       subtitle = "Vergelijking tussen aantal statusveranderingen en unieke studenten",
       x = "Schooljaar",
       y = "Aantal",
       color = "Metriek") +
  scale_y_continuous(labels = comma) +
  scale_color_manual(values = c("Aantal Statusveranderingen" = "#4393C3", "Unieke Studenten" = "#E8A15D")) +
  theme(legend.position = "bottom")

```


### Conclusie Aanmeldingsoverzicht

Uit de analyse van de aanmeldingsgegevens over verschillende jaren blijkt dat we te maken hebben met aanzienlijke datakwaliteitsproblemen in eerdere jaren. Het jaar 0 bevat een groot aantal aanmeldingen, wat waarschijnlijk duidt op ontbrekende jaarinformatie. Daarnaast zien we dat de jaren 2023 en 2024 veel vollediger zijn dan eerdere jaren.
Voor verdere analyses zullen we ons daarom concentreren op alleen de jaren 2023 en 2024, omdat:

1. Deze jaren de meest recente en relevante informatie bevatten
2. De datakwaliteit en -volledigheid voor deze jaren veel beter is
3. We daarmee werken met een consistente dataset voor trendanalyses

```{r}
#| label: filter-recent-years

# Filter voor recente jaren (2023 en 2024)
applications_recent <- applications_enriched %>%
  filter(schooljaar %in% c(2023, 2024))

# Toon aantal rijen na filtering
cat(sprintf("Aantal rijen na filtering op 2023-2024: %d\n", nrow(applications_recent)))
cat(sprintf("Percentage van originele data: %.1f%%\n", 
            nrow(applications_recent) / nrow(applications_enriched) * 100))

```

## 3. Analyse van dubbele aanmeldingen

Een belangrijke focus voor werving en voorlichting is het analyseren van studenten die zich aanmelden voor meerdere opleidingen of instellingen. Het begrijpen van dit gedrag kan helpen bij het ontwikkelen van gerichte strategieën.

Een cruciale observatie uit de data is dat één aanmelding meerdere regels in de dataset kan hebben. Dit komt doordat elke statuswijziging (bijv. van "SUBMITTED" naar "OFFERED" of naar "ENROLLED") wordt vastgelegd als een nieuwe regel. Om correcte analyses te kunnen doen, moeten we eerst deze rijen groeperen.

```{r}
#| label: double-applications

# Identify and analyze double applications
applications_grouped <- applications_recent %>%
    mutate(begindatum = as.Date(begindatum)) %>%
    group_by(bsnhash, schooljaar, opleidingcode, Opleidingsnaam, instellingserkenningscode, school) %>%
    summarise(
        application_duration_days = as.numeric(max(begindatum) - min(begindatum)),
        statusses = paste(status, collapse = ", "),
        is_enrolled = any(status == "ENROLLED"),
        leertrajectmbo = paste(unique(leertrajectmbo), collapse = ", "),
        statussource = paste(unique(statussource), collapse = ", "),
        .groups = "drop"
    )

# Toon het verschil in aantal rijen
cat(sprintf("Aantal rijen vóór groepering: %d\n", nrow(applications_recent)))
cat(sprintf("Aantal rijen na groepering: %d\n", nrow(applications_grouped)))
```


We groeperen de aanmeldingen niet alleen per instelling-opleiding, maar ook enkel bij instelling. Dit doen we omdat er het vermoeden is dat sommige instellingen bij studenten die zich aanmelden voor meerdere opleidingen binnen CAMBO slechts 1 aanmelding leveren.

```{r}

applications_grouped_by_institution <- applications_recent %>%
    mutate(begindatum = as.Date(begindatum)) %>%
    group_by(bsnhash, schooljaar, instellingserkenningscode, school) %>%
    summarise(
        application_duration_days = as.numeric(max(begindatum) - min(begindatum)),
        statusses = paste(status, collapse = ", "),
        is_enrolled = any(status == "ENROLLED"),
        leertrajectmbo = paste(unique(leertrajectmbo), collapse = ", "),
        statussource = paste(unique(statussource), collapse = ", "),
        .groups = "drop"
    )

```

Het grote verschil in aantal rijen vóór en na groepering bevestigt hoe belangrijk deze stap is. We zien dat veel aanmeldingen meerdere statuswijzigingen ondergaan, wat kan wijzen op een complex administratief proces.

Nu kunnen we analyseren hoeveel aanmeldingen elke student heeft (alleen eerste 10 rijen worden getoond):

```{r}
#| label: analyze-multiple-applications

# We breiden de dataset uit met informatie over meervoudige aanmeldingen
applications_grouped_multiple <- applications_grouped %>%
    group_by(bsnhash, schooljaar) %>%
    add_tally(name = "applications_total_number") %>%
    ungroup() %>%
    group_by(bsnhash, schooljaar, instellingserkenningscode) %>%
    add_tally(name = "applications_total_number_within_institution") %>%
    ungroup() %>%
    group_by(bsnhash, schooljaar) %>%
    mutate(applications_total_number_of_institutions = length(unique(instellingserkenningscode))) %>%
    ungroup()

# Voeg boolean flags toe voor verschillende soorten meervoudige aanmeldingen
applications_grouped_multiple_bools <- applications_grouped_multiple %>%
    mutate(
        applications_is_multiple = applications_total_number > 1,
        applications_is_multiple_within_institution = applications_total_number_within_institution > 1,
        applications_is_multiple_across_institutions = applications_total_number_of_institutions > 1
    )

# Analyseer conversiepercentages per type aanmelding
applications_conversion <- applications_grouped_multiple_bools %>%
    group_by(
        schooljaar,
        applications_is_multiple,
        applications_is_multiple_within_institution,
        applications_is_multiple_across_institutions
    ) %>% 
    summarise(
        total = n(),
        enrolled = sum(is_enrolled, na.rm = TRUE),
        conversion_rate = mean(is_enrolled, na.rm = TRUE) * 100,
        .groups = "drop"
    )

```

```{r}
#| label: conversion-by-application-type

# Visualisatie van conversie per type aanmelding, gesorteerd op conversiepercentage
applications_conversion %>%
  mutate(
    application_type = case_when(
      applications_is_multiple_within_institution & applications_is_multiple_across_institutions ~ 
        "Opleidingen binnen én tussen instellingen",
      applications_is_multiple_within_institution ~ "Opleidingen binnen dezelfde instelling",
      applications_is_multiple_across_institutions ~ "Zelfde opleiding bij verschillende instellingen",
      TRUE ~ "Slechts één aanmelding"
    )
  ) %>%
  # Bereken het gemiddelde conversiepercentage per type aanmelding voor sortering
  group_by(application_type) %>%
  mutate(avg_conversion = mean(conversion_rate)) %>%
  ungroup() %>%
  # Nu de visualisatie
  ggplot(aes(x = reorder(application_type, -avg_conversion), y = conversion_rate, fill = factor(schooljaar))) +
  geom_col(position = "dodge") +
  geom_text(aes(label = paste0(round(conversion_rate, 1), "%")), 
            position = position_dodge(width = 0.9),
            vjust = -0.5, size = 3) +
  scale_fill_brewer(palette = "Set1") +
  scale_y_continuous(limits = c(0, 75)) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Conversiepercentage per Type Aanmelding",
       subtitle = "Vergelijking tussen 2023 en 2024",
       x = NULL,
       y = "Conversiepercentage (%)",
       fill = "Schooljaar")

```

```{r}
#| label: multiple-applications-count

# Visualisatie van verdeling van het aantal aanmeldingen per student
applications_count_distribution <- applications_grouped_multiple %>%
  select(bsnhash, schooljaar, applications_total_number) %>%
  distinct() %>%
  group_by(schooljaar, applications_total_number) %>%
  summarise(
    students = n(),
    .groups = "drop"
  ) %>%
  group_by(schooljaar) %>%
  mutate(
    students_pct = students / sum(students) * 100
  ) %>%
  ungroup() %>%
  filter(applications_total_number <= 10)  # Beperk tot 10 voor visualisatie

# Toon alleen de eerste 10 waarden voor overzichtelijkheid
ggplot(applications_count_distribution %>% filter(schooljaar %in% c(2023, 2024)), 
       aes(x = students_pct, 
           fill = factor(schooljaar, levels = c("2023", "2024")),
           y = reorder(factor(applications_total_number), -as.numeric(applications_total_number))))  +
  geom_col(position = "dodge") +
  geom_text(aes(label = paste0(round(students_pct, 1), "%")), 
            position = position_dodge(width = 0.9),
            hjust = -0.2, size = 3) +
  scale_fill_brewer(palette = "Set1") +
    scale_x_continuous(limits = c(0, 100)) +
  theme_minimal() +
  labs(title = "Verdeling van Aantal Aanmeldingen per Student",
       subtitle = "Percentage studenten per aantal aanmeldingen",
              x = "Percentage Studenten (%)",
       y = "Aantal Aanmeldingen per Student",
       fill = "Schooljaar")

```

We zien hierboven dat de meeste studenten slechts één aanmelding hebben, maar een significant aantal heeft meerdere aanmeldingen. Laten we dit visualiseren:

```{r}
#| label: multiple-application-count

# Correct calculation of conversion rates by application count
# First, get student-level enrollment status
student_enrollment <- applications_grouped_multiple %>%
  select(bsnhash, schooljaar, applications_total_number, is_enrolled) %>%
  group_by(bsnhash, schooljaar) %>%
  summarise(
    applications_total_number = first(applications_total_number),
    student_enrolled = any(is_enrolled),
    .groups = "drop"
  )

# Then calculate conversion rates per application count
conversion_by_count <- student_enrollment %>%
  group_by(schooljaar, applications_total_number) %>%
  summarise(
    students = n(),
    converted_students = sum(student_enrolled),
    student_conversion_rate = mean(student_enrolled) * 100,
    .groups = "drop"
  ) %>%
  filter(applications_total_number <= 10)  # Limit to 10 for visualization

# Calculate application-level conversion rate
conversion_by_count <- conversion_by_count %>%
  mutate(
    application_conversion_rate = converted_students / (students * applications_total_number) * 100
  )

# Visualize application-level conversion rate with flipped axes and reversed order
ggplot(conversion_by_count %>% filter(schooljaar %in% c(2023, 2024)), 
       aes(y = reorder(factor(applications_total_number), -as.numeric(applications_total_number)), 
           x = application_conversion_rate, 
           fill = factor(schooljaar, levels = c("2023", "2024")))) +  # Reverse year order
  geom_col(position = "dodge") +
  geom_text(aes(label = paste0(round(application_conversion_rate, 1), "%")), 
            position = position_dodge(width = 0.9),
            color = "white",
            hjust = 1, size = 3) +
  scale_fill_brewer(palette = "Set1") +
  theme_minimal() +
  labs(title = "Conversiepercentage per Aanmelding naar Aantal Aanmeldingen",
       subtitle = "Percentage van aanmeldingen dat resulteert in inschrijving",
       y = "Aantal Aanmeldingen per Student",
       x = "Conversie per Aanmelding (%)",
       fill = "Schooljaar")


```

### Inzichten Dubbele Aanmeldingen

Deze analyse biedt belangrijke inzichten in het aanmeldingsgedrag van studenten:

1. De meerderheid van de studenten (meer dan 80%) heeft slechts één aanmelding
2. Studenten met meerdere aanmeldingen hebben vaak een hogere kans om zich daadwerkelijk in te schrijven
3. We zien een interessante piek in conversie bij studenten die precies 2 aanmeldingen hebben
4. Bij meer dan 5 aanmeldingen neemt de conversiekans meestal af, wat kan duiden op meer onzekerheid

Deze inzichten kunnen gebruikt worden voor gerichte begeleiding van studenten met meerdere aanmeldingen, aangezien zij een hogere conversiekans vertegenwoordigen maar ook meer begeleiding kunnen nodig hebben bij hun studiekeuze.

## 4. Analyse van Opleidingen en Instellingen

Laten we analyseren welke opleidingen en instellingen de hoogste en laagste aanmeldingsvolumes en conversiepercentages hebben. Dit helpt bij het identificeren van succesvolle programma's en potentiële verbeterpunten.

Let op: Ik heb gefilterd bij opleidingen op minimaal 50 en bij instellingen op minimaal 100. Een aantal instellingen had een lager aantal.

```{r}
#| label: program-analysis

# Top en Laagste opleidingen op basis van aanmeldingsvolume
# We gebruiken applications_grouped om unieke aanmeldingen te tellen
top_programs <- applications_grouped %>%
  filter(!is.na(Opleidingsnaam)) %>%
  group_by(opleidingcode, Opleidingsnaam) %>%
  summarise(
    applications = n(),
    conversions = sum(is_enrolled),
    conversion_rate = mean(is_enrolled) * 100,
    .groups = "drop"
  ) %>%
  arrange(desc(conversion_rate)) %>%
    filter(conversions > 20)

# Haal top 5 en Laagste 5 op basis van volume
top5_programs <- head(top_programs, 5)
bottom5_programs <- tail(top_programs %>% filter(applications >= 10), 5)  # Minimum van 10 aanmeldingen voor relevantie

# Combineer voor visualisatie
top_bottom_programs <- bind_rows(
  mutate(top5_programs, categorie = "Top 5"),
  mutate(bottom5_programs, categorie = "Laagste 5")
)


```

```{r}
#| label: programme-table

# Toon top en bottom opleidingen in een mooie tabel
top_bottom_programs %>%
  gt() %>%
  tab_header(
    title = "Top 5 en Laagste 5 Opleidingen op Conversiepercentage",
    subtitle = "Gebaseerd op gegroepeerde aanmeldingsgegevens van opleidingen met > 50 inschrijvingen"
  ) %>%
    cols_hide(columns = categorie) %>%  # Verberg de categoriekolom
  cols_label(
    opleidingcode = "Code",
    Opleidingsnaam = "Opleidingsnaam",
    applications = "Aanmeldingen",
    conversions = "Inschrijvingen",
    conversion_rate = "Conversie (%)"
  ) %>%
  fmt_number(
    columns = c(applications, conversions),
    decimals = 0
  ) %>%
  fmt_percent(
    columns = conversion_rate,
    decimals = 1,
    scale_values = FALSE
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#e6f7ff")
    ),
    locations = cells_body(
      rows = conversion_rate > mean(top_bottom_programs$conversion_rate)
    )
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#ccffcc")
    ),
    locations = cells_body(
      rows = categorie == "Top 5"
    )
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#ffcccc")
    ),
    locations = cells_body(
      rows = categorie == "Laagste 5"
    )
  )

```

```{r}
#| label: institution-analysis

# Top en bottom instellingen op basis van aanmeldingsvolume
top_institutions <- applications_grouped %>%
  #filter(!is.na(school)) %>%
  group_by(instellingserkenningscode, school) %>%
  summarise(
    applications = n(),
    conversions = sum(is_enrolled),
    conversion_rate = mean(is_enrolled) * 100,
    .groups = "drop"
  ) %>%
  arrange(desc(conversion_rate)) %>%
    filter(applications > 100) %>%
    mutate(school = ifelse(school == "STC (Scheepvaart en Transport College)", 
                           "STC", 
                           school))

# Haal top 5 en bottom 5 op basis van volume
top5_institutions <- head(top_institutions, 5)
bottom5_institutions <- tail(top_institutions %>% filter(applications >= 10), 5)  # Minimum van 10 aanmeldingen voor relevantie

# Combineer voor visualisatie
top_bottom_institutions <- bind_rows(
  mutate(top5_institutions, categorie = "Top 5"),
  mutate(bottom5_institutions, categorie = "Laagste 5")
)

```

```{r}
#| label: institution-table

# Toon top en bottom instellingen in een mooie tabel
top_bottom_institutions %>%
  gt() %>%
  tab_header(
    title = "Top 5 en laagste 5 Instellingen op conversiepercentage",
    subtitle = "Gebaseerd op gegroepeerde aanmeldingsgegevens"
  ) %>%
    cols_hide(columns = c(instellingserkenningscode, categorie)) %>%  # Verberg de categoriekolom
  cols_label(
    school = "Instelling",
    applications = "Aanmeldingen",
    conversions = "Inschrijvingen",
    conversion_rate = "Conversie (%)"
  ) %>%
  fmt_number(
    columns = c(applications, conversions),
    decimals = 0
  ) %>%
  fmt_percent(
    columns = conversion_rate,
    decimals = 1,
    scale_values = FALSE
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#e6f7ff")
    ),
    locations = cells_body(
      rows = conversion_rate > mean(top_bottom_institutions$conversion_rate)
    )
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#ccffcc")
    ),
    locations = cells_body(
      rows = categorie == "Top 5"
    )
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#ffcccc")
    ),
    locations = cells_body(
      rows = categorie == "Laagste 5"
    )
  )

```

```{r}
#| label: program-conversion-interactive

# Bereid data voor, behandel Top 5 en Laagste 5 als afzonderlijke datasets
top5_programs <- top_bottom_programs %>% 
  filter(categorie == "Top 5") %>%
  arrange(desc(conversion_rate)) %>%
  mutate(
    text_position = "inside",
    text_color = "black"
  )

bottom5_programs <- top_bottom_programs %>% 
  filter(categorie == "Laagste 5") %>%
  arrange(desc(conversion_rate)) %>%
  mutate(
    text_position = "outside",
    text_color = "black"
  )

# Combineer ze weer in de gewenste volgorde
ordered_programs <- bind_rows(top5_programs, bottom5_programs) %>%
  # Maak een clean label zonder de interactie artifacts
  mutate(
    display_name = Opleidingsnaam,
    # Voeg ruwe index toe voor expliciete sortering
    idx = row_number()
  )

programs_plot_data <- rbind(
  cbind(top5_programs, group = "Top 5"),
  cbind(bottom5_programs, group = "Laagste 5")
)

# Zorg ervoor dat de volgorde van de opleidingen correct is
# Gebruik unique() om duplicaten te voorkomen in factor levels
programs_plot_data$Opleidingsnaam <- factor(
  programs_plot_data$Opleidingsnaam, 
  levels = rev(unique(ordered_programs$Opleidingsnaam))  # unique() voorkomt duplicaten
)

# Maak de ggplot
ggplot(programs_plot_data, aes(x = conversion_rate, y = Opleidingsnaam, fill = group)) +
  geom_col(position = position_dodge(width = 0.9)) +
  geom_text(
    aes(
      label = paste0(round(conversion_rate, 1), "%"),
      hjust = ifelse(group == "Top 5", 1.2, -0.2)
    ),
    position = position_dodge(width = 0.9),
    color = ifelse(programs_plot_data$group == "Top 5", "white", "black"),
    size = 3.5
  ) +
  scale_fill_manual(values = c("Top 5" = "#1976D2", "Laagste 5" = "#FF9800")) +
  labs(
    title = "Conversie Top 5 en Laagste 5",
    x = "Conversiepercentage (%)",
    y = ""
  ) +
  theme_minimal() +
  theme(
    legend.title = element_blank(),
    legend.position = "top",
    plot.margin = margin(5, 50, 5, 5),  # Extra marge rechts voor labels
    axis.text.y = element_text(size = 10)
  )

```



```{r}
#| label: institution-conversion-interactive

# Bereid data voor, behandel Top 5 en Laagste 5 als afzonderlijke datasets
top5_institutions <- top_bottom_institutions %>% 
  filter(categorie == "Top 5") %>%
  arrange(desc(conversion_rate)) %>%
  mutate(
    text_position = "inside",
    text_color = "white"
  )

bottom5_institutions <- top_bottom_institutions %>% 
  filter(categorie == "Laagste 5") %>%
  arrange(desc(conversion_rate)) %>%
  mutate(
    text_position = "outside",
    text_color = "black"
  )

# Combineer ze weer in de gewenste volgorde
ordered_institutions <- bind_rows(top5_institutions, bottom5_institutions) %>%
  # Maak een clean label zonder de interactie artifacts
  mutate(
    display_name = school,
    # Voeg ruwe index toe voor expliciete sortering
    idx = row_number()
  )

# Visualisatie 1: Conversiepercentages van top en laagste instellingen
# Combineer de datasets voor eenvoudiger plotten
institutions_plot_data <- rbind(
  cbind(top5_institutions, group = "Top 5"),
  cbind(bottom5_institutions, group = "Laagste 5")
)

# Zorg ervoor dat de volgorde van de instellingen correct is
institutions_plot_data$school <- factor(
  institutions_plot_data$school, 
  levels = rev(ordered_institutions$school)  # rev() om dezelfde volgorde als plotly te krijgen
)

# Maak de ggplot
ggplot(institutions_plot_data, aes(x = conversion_rate, y = school, fill = group)) +
  geom_col(position = position_dodge(width = 0.9)) +
  geom_text(
    aes(
      label = paste0(round(conversion_rate, 1), "%"),
      hjust = ifelse(group == "Top 5", 1.2, -0.2)
    ),
    position = position_dodge(width = 0.9),
    color = ifelse(institutions_plot_data$group == "Top 5", "white", "black"),
    size = 3.5
  ) +
  scale_fill_manual(values = c("Top 5" = "#1976D2", "Laagste 5" = "#FF9800")) +
  labs(
    title = "Conversie Top 5 en Laagste 5",
    x = "Conversiepercentage (%)",
    y = ""
  ) +
  theme_minimal() +
  theme(
    legend.title = element_blank(),
    legend.position = "top",
    plot.margin = margin(5, 50, 5, 5),  # Extra marge rechts voor labels
    axis.text.y = element_text(size = 10)
  )

```

### Inzichten Opleidingen en Instellingen

Deze analyse geeft waardevolle inzichten in de verschillen tussen opleidingen en instellingen:

1. Er zijn grote verschillen in zowel het aantal aanmeldingen als de conversiepercentages tussen opleidingen en instellingen
2. Populaire opleidingen hebben niet altijd de hoogste conversiepercentages, wat kan wijzen op selectieve toelatingsprocedures
3. Bij kleine opleidingen en instellingen zien we soms verrassend hoge conversiepercentages, wat kansen voor groei kan aangeven
4. Deze inzichten kunnen gebruikt worden voor:
   - Gerichte marketingcampagnes voor opleidingen met groeipotentieel
   - Analyse van succesvolle conversiestrategieën bij kleinere opleidingen
   - Identificatie van opleidingen die mogelijk extra ondersteuning nodig hebben bij werving

Door zowel top als bottom opleidingen en instellingen te analyseren, krijgen we een completer beeld van het hele spectrum en kunnen we specifiekere strategieën ontwikkelen.

### Kwaliteitscontrole aantal aanmeldingen

Bij bovenstaande analyse valt op dat sommige instellingen een ongebruikelijk hoge conversie hebben. Dit leidde tot de vraag of instellingen niet aanmeldingen hergebruiken. Dat wil zeggen dat een student die zich bij een instelling voor meerdere opleidingen aanmeldt, in CAMBO toch maar één keer verschijnt voor deze instelling.

Om dit te controleren kijken we naar het aantal aanmeldingen in CAMBO per instelling.

```{r}
#| label: application-quality-control
 
applications_within_institution <- applications_grouped_by_institution |>
    count(school)
    
applications_within_institution_programmes_combi <- applications_grouped |>
    count(school)

school_differences <- full_join(applications_within_institution, applications_within_institution_programmes_combi, by = "school") |>
    filter(!is.na(school)) |>
    mutate(
        # Bereken aanmeldingen per student
        aanmeldingen_per_student = n.y / n.x
  ) |>
    arrange(desc(aanmeldingen_per_student))


```


```{r}
#| label: application-quality-control-plot
#| fig.height: 10

# Creëer een horizontale staafgrafiek met verbeterde weergave
ggplot(school_differences |> 
         mutate(school = fct_reorder(school, aanmeldingen_per_student)), 
       aes(x = aanmeldingen_per_student , y = school, fill = aanmeldingen_per_student)) +
  # Begin de x-as bij 0 (dit is 1.00 in werkelijkheid)
  geom_col(width = 0.7) +
  geom_text(aes(
              label = sprintf("%.2f", aanmeldingen_per_student),
              x = aanmeldingen_per_student),  # Gebruik de exacte positie van het einde van de balk
            hjust = -0.2,  # Negatieve waarde plaatst de tekst rechts van het punt
            size = 3) +
  # Driekleuren verloop: lichtblauw (normaal) naar grijs naar oranje (verdacht)
  scale_fill_gradientn(
    colors = c("#4393C3", "#D9D9D9", "#E8A15D"),  # Lichtblauw, grijs, oranje
    values = scales::rescale(c(1.3, 1.10, 1.0)),   # Posities van de kleuren aanpassen
    #name = "Aanmeldingen\nper student"
  ) +
  # Fix x-as om bij 0 te beginnen maar labels vanaf 1.00 te tonen
  scale_x_continuous(
    #labels = function(x) x + 1,
    breaks = seq(0, max(school_differences$aanmeldingen_per_student), by = 0.25),
    expand = expansion(mult = c(0, 0.15))  # Extra ruimte links voor labels
  ) +
  # Labels
  labs(
    title = "Gemiddeld aantal aanmeldingen per student binnen instelling",
    subtitle = "Waarden dicht bij 1.00 duiden op mogelijke datakwaliteitsproblemen",
    x = NULL,
    y = NULL
  ) +
  # Eenvoudige, schone layout
theme_minimal() +
  theme(
    legend.position = "none",
    legend.title = element_text(size = 8),
    panel.grid = element_blank(),
    axis.title.x = element_text(hjust = 1),
    plot.title = element_text(face = "bold", hjust = 1), # Rechts uitlijnen (hjust = 1)
    plot.subtitle = element_text(color = "darkgray", hjust = 1), # Ook rechts uitlijnen
    axis.text.x = element_text(hjust = 0.5),
    plot.margin = margin(t = 20, r = 20, b = 10, l = 10) # Extra marge bovenaan
  )

```

We zien dat sommige instellingen nooit meer dan één aanmelding per student heeft (1.00). Dat is mogelijk bij vakscholen, maar bij bredere instellingen zeer onwaarschijnlijk.

## 5. Tijd Analyse

De timing van aanmeldingen gedurende het jaar is cruciaal voor effectieve marketing en capaciteitsplanning. Door te analyseren wanneer studenten zich aanmelden en hoe dit verband houdt met conversie, kunnen we inzicht krijgen in de meest kritieke periodes in de aanmeldingscyclus.


```{r}
#| label: temporal-analysis

# We hebben de originele data nodig voor de temporele analyse, omdat begindatum  niet behouden wordt in de gegroepeerde data
# We moeten een aangepaste groepering maken die begindatum behoudt
applications_grouped_with_date <- applications_recent %>%
    mutate(begindatum = as.Date(begindatum)) %>%
    group_by(bsnhash, schooljaar, opleidingcode, Opleidingsnaam, instellingserkenningscode, school) %>%
    summarise(
        application_duration_days = as.numeric(max(begindatum) - min(begindatum)),
        earliest_date = min(begindatum),  # Bewaar de eerste aanmelddatum
        statusses = paste(status, collapse = ", "),
        is_enrolled = any(status == "ENROLLED"),
        leertrajectmbo = paste(unique(leertrajectmbo), collapse = ", "),
        statussource = paste(unique(statussource), collapse = ", "),
        .groups = "drop"
    )

# Converteer datums naar het juiste formaat voor temporele analyse
applications_temporal <- applications_grouped_with_date %>%
  mutate(
    month = floor_date(earliest_date, "month"),
    year = year(earliest_date),
    month_number = month(earliest_date)
  )

monthly_applications <- applications_temporal %>%
    mutate(
        academic_year = if_else(month_number >= 10, schooljaar, schooljaar - 1),
        academic_month = if_else(month_number >= 10, 
                                 month_number - 9,    # Oct (10) becomes 1
                                 month_number + 3)    # Jan (1) becomes 4
    ) %>%
    group_by(schooljaar, academic_year, academic_month) %>%
    summarise(
        applications = n(),
        conversions = sum(is_enrolled),
        conversion_rate = mean(is_enrolled) * 100,
        .groups = "drop"
    )
# Create month labels for academic year
academic_month_labels <- c("Oct", "Nov", "Dec", "Jan", "Feb", "Mar", 
                           "Apr", "May", "Jun", "Jul", "Aug", "Sep")


```

We vergelijken eerst de aanmeldingen per maand tussen 2023 en 2024. Dit laat zien of er veranderingen zijn in het aanmeldingspatroon van jaar tot jaar, wat belangrijk is voor trendanalyse.

```{r}
#| label: monthly-comparison-plot

# Visualisatie: vergelijking van maandelijkse patronen per schooljaar
ggplot(monthly_applications, 
       aes(x = academic_month, y = applications, 
           color = factor(schooljaar), group = factor(schooljaar))) +
  geom_line(size = 1.2) +
  geom_point(size = 2.5) +
  scale_x_continuous(breaks = 1:12, labels = academic_month_labels) +
  theme_minimal() +
  labs(title = "Maandelijkse Aanmeldingen per Schooljaar",
       subtitle = "Oktober t/m September",
       x = "Maand",
       y = "Aantal Aanmeldingen",
       color = "Schooljaar") +
  scale_y_continuous(labels = comma) +
  scale_color_brewer(palette = "Set1")

```

Niet alleen het volume is belangrijk, maar ook de conversiepercentages per maand. Dit kan onthullen wanneer de meest "serieuze" studenten zich aanmelden.

```{r}
#| label: conversion-comparison-plot

# Visualisatie: vergelijking van conversiepercentages per schooljaar
ggplot(monthly_applications, 
       aes(x = academic_month, y = conversion_rate, 
           color = factor(schooljaar), group = factor(schooljaar))) +
  geom_line(size = 1.2) +
  geom_point(size = 2.5) +
  scale_x_continuous(breaks = 1:12, labels = academic_month_labels) +
  theme_minimal() +
  labs(title = "Maandelijkse Conversiepercentages per Jaar",
       subtitle = "Vergelijking tussen 2023 en 2024",
       x = "Maand",
       y = "Conversiepercentage (%)",
       color = "Schooljaar") +
  scale_y_continuous(labels = function(x) paste0(x, "%"),
                     limits = c(0, NA)) +
  scale_color_brewer(palette = "Set1")

```

## 6. Geografische Analyse van Studentenherkomst

Voor inzicht in de geografische spreiding van studenten analyseren we waar MBO Amersfoort studenten vandaan komen op basis van postcode. We berekenen het percentage studenten per postcode relatief aan het totaal aantal MBO Amersfoort studenten voor 2023 en 2024.

```{r}
#| label: geographic-preparation

# Filter alleen ingeschreven studenten voor MBO Amersfoort
mbo_amersfoort_enrolled <- applications_enriched %>%
    filter(
        status == "ENROLLED",
        school == "MBO Amersfoort",
        schooljaar %in% c(2023, 2024),
        !is.na(postcodecijfers)
    ) %>%
    # Convert postal code to 4-digit string
    mutate(
        postcode_4 = sprintf("%04d", postcodecijfers)
    ) %>%
    filter(nchar(postcode_4) == 4)

# Count unique students per postcode per year for MBO Amersfoort
mbo_students_by_postcode <- mbo_amersfoort_enrolled %>%
    group_by(schooljaar, postcode_4) %>%
    summarise(
        mbo_amersfoort_students = n_distinct(bsnhash),
        .groups = "drop"
    )

# Count total unique students per postcode per year (all institutions)
total_students_by_postcode <- applications_enriched %>%
    filter(
        status == "ENROLLED",
        schooljaar %in% c(2023, 2024),
        !is.na(postcodecijfers)
    ) %>%
    mutate(
        postcode_4 = sprintf("%04d", postcodecijfers)
    ) %>%
    filter(nchar(postcode_4) == 4) %>%
    group_by(schooljaar, postcode_4) %>%
    summarise(
        total_students = n_distinct(bsnhash),
        .groups = "drop"
    )

# Calculate percentage of MBO Amersfoort students per postcode relative to total MBO Amersfoort
# First get total MBO Amersfoort students per year
mbo_amersfoort_totals <- mbo_students_by_postcode %>%
    group_by(schooljaar) %>%
    summarise(total_mbo_amersfoort = sum(mbo_amersfoort_students), .groups = "drop")

# Calculate postcode distribution within MBO Amersfoort
postcode_distribution_analysis <- mbo_students_by_postcode %>%
    left_join(mbo_amersfoort_totals, by = "schooljaar") %>%
    mutate(
        postcode_percentage = (mbo_amersfoort_students / total_mbo_amersfoort) * 100
    ) %>%
    filter(mbo_amersfoort_students >= 2)  # Only postcodes with at least 2 MBO Amersfoort students

cat("Analyse van postcode verdeling MBO Amersfoort\n")
cat("Aantal postcodes in analyse:", nrow(postcode_distribution_analysis), "\n")
cat("Schooljaren:", paste(unique(postcode_distribution_analysis$schooljaar), collapse = ", "), "\n")

```

```{r}
#| label: market-share-summary

# Summary statistics per year
postcode_distribution_summary <- postcode_distribution_analysis %>%
    group_by(schooljaar) %>%
    summarise(
        postcodes_with_students = sum(mbo_amersfoort_students > 0),
        total_postcodes = n(),
        avg_postcode_percentage = mean(postcode_percentage, na.rm = TRUE),
        max_postcode_percentage = max(postcode_percentage, na.rm = TRUE),
        total_mbo_students = sum(mbo_amersfoort_students),
        .groups = "drop"
    )

# Show summary table
postcode_distribution_summary %>%
    gt() %>%
    tab_header(
        title = "MBO Amersfoort Postcode Verdeling Samenvatting",
        subtitle = "Per schooljaar"
    ) %>%
    cols_label(
        schooljaar = "Schooljaar",
        postcodes_with_students = "Postcodes met studenten",
        total_postcodes = "Totaal postcodes",
        avg_postcode_percentage = "Gemiddeld percentage per postcode (%)",
        max_postcode_percentage = "Maximaal percentage per postcode (%)",
        total_mbo_students = "Totaal MBO studenten"
    ) %>%
    fmt_number(
        columns = c(postcodes_with_students, total_postcodes, total_mbo_students),
        decimals = 0
    ) %>%
    fmt_number(
        columns = c(avg_postcode_percentage, max_postcode_percentage),
        decimals = 1
    )

```

```{r}
#| label: geographic-data-preparation

# Load postal code geographic data
postal_code_geo <- sf::st_read("data/reference/cbs_pc4_2024_v1.gpkg", quiet = TRUE)

# Transform to WGS84 for leaflet
postal_code_geo_wgs84 <- sf::st_transform(postal_code_geo, crs = 4326)

# Join postcode distribution data with geographic data for 2023
postcode_distribution_2023 <- postcode_distribution_analysis %>%
    filter(schooljaar == 2023) %>%
    mutate(postcode = as.numeric(postcode_4)) %>%
    select(-postcode_4)

geo_distribution_2023 <- postal_code_geo_wgs84 %>%
    left_join(postcode_distribution_2023, by = "postcode") %>%
    mutate(
        postcode_percentage = replace_na(postcode_percentage, 0),
        has_mbo_students = replace_na(mbo_amersfoort_students, 0) > 0
    )

# Join postcode distribution data with geographic data for 2024
postcode_distribution_2024 <- postcode_distribution_analysis %>%
    filter(schooljaar == 2024) %>%
    mutate(postcode = as.numeric(postcode_4)) %>%
    select(-postcode_4)

geo_distribution_2024 <- postal_code_geo_wgs84 %>%
    left_join(postcode_distribution_2024, by = "postcode") %>%
    mutate(
        postcode_percentage = replace_na(postcode_percentage, 0),
        has_mbo_students = replace_na(mbo_amersfoort_students, 0) > 0
    )

```

```{r}
#| label: market-share-map-2023

# Create color scale function for postcode percentage
create_postcode_percentage_colors <- function(postcode_percentage) {
    # Use a blue to red color scale
    color_palette <- colorNumeric(
        palette = c("#FFFFFF", "#FFFFCC", "#FED976", "#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#B10026"),
        domain = c(0, max(postcode_distribution_analysis$postcode_percentage, na.rm = TRUE)),
        na.color = "transparent"
    )
    return(color_palette(postcode_percentage))
}

# Map for 2023
map_2023 <- leaflet(geo_distribution_2023) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    addPolygons(
        fillColor = ~create_postcode_percentage_colors(postcode_percentage),
        fillOpacity = 0.8,
        color = "white",
        weight = 0.5,
        popup = ~paste0(
            "<b>Postcode:</b> ", postcode, "<br>",
            "<b>MBO Amersfoort studenten:</b> ", replace_na(mbo_amersfoort_students, 0), "<br>",
            "<b>Percentage van MBO Amersfoort:</b> ", round(postcode_percentage, 1), "%"
        ),
        label = ~paste0(postcode, ": ", round(postcode_percentage, 1), "% van MBO Amersfoort"),
        highlightOptions = highlightOptions(
            weight = 2,
            color = "black",
            fillOpacity = 1,
            bringToFront = TRUE
        )
    ) %>%
    addLegend(
        pal = colorNumeric(
            palette = c("#FFFFFF", "#FFFFCC", "#FED976", "#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#B10026"),
            domain = c(0, max(postcode_distribution_analysis$postcode_percentage, na.rm = TRUE))
        ),
        values = ~postcode_percentage,
        title = "Percentage (%)",
        position = "bottomright"
    ) %>%
    setView(lng = 5.2, lat = 52.2, zoom = 8)

# Display 2023 map
cat("## MBO Amersfoort Postcode Verdeling - 2023\n\n")
map_2023

```

```{r}
#| label: market-share-map-2024

# Map for 2024
map_2024 <- leaflet(geo_distribution_2024) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    addPolygons(
        fillColor = ~create_postcode_percentage_colors(postcode_percentage),
        fillOpacity = 0.8,
        color = "white",
        weight = 0.5,
        popup = ~paste0(
            "<b>Postcode:</b> ", postcode, "<br>",
            "<b>MBO Amersfoort studenten:</b> ", replace_na(mbo_amersfoort_students, 0), "<br>",
            "<b>Percentage van MBO Amersfoort:</b> ", round(postcode_percentage, 1), "%"
        ),
        label = ~paste0(postcode, ": ", round(postcode_percentage, 1), "% van MBO Amersfoort"),
        highlightOptions = highlightOptions(
            weight = 2,
            color = "black",
            fillOpacity = 1,
            bringToFront = TRUE
        )
    ) %>%
    addLegend(
        pal = colorNumeric(
            palette = c("#FFFFFF", "#FFFFCC", "#FED976", "#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#B10026"),
            domain = c(0, max(postcode_distribution_analysis$postcode_percentage, na.rm = TRUE))
        ),
        values = ~postcode_percentage,
        title = "Percentage (%)",
        position = "bottomright"
    ) %>%
    setView(lng = 5.2, lat = 52.2, zoom = 8)

# Display 2024 map
cat("## MBO Amersfoort Postcode Verdeling - 2024\n\n")
map_2024

```

```{r}
#| label: top-postcodes-analysis

# Find top postcodes for MBO Amersfoort
top_postcodes_2023 <- postcode_distribution_analysis %>%
    filter(schooljaar == 2023, mbo_amersfoort_students > 0) %>%
    arrange(desc(mbo_amersfoort_students)) %>%
    head(10)

top_postcodes_2024 <- postcode_distribution_analysis %>%
    filter(schooljaar == 2024, mbo_amersfoort_students > 0) %>%
    arrange(desc(mbo_amersfoort_students)) %>%
    head(10)

# Combine for comparison
top_postcodes_comparison <- bind_rows(
    mutate(top_postcodes_2023, jaar = 2023),
    mutate(top_postcodes_2024, jaar = 2024)
) %>%
    select(jaar, postcode_4, mbo_amersfoort_students, postcode_percentage) %>%
    arrange(desc(mbo_amersfoort_students))

# Display top postcodes table
top_postcodes_comparison %>%
    gt() %>%
    tab_header(
        title = "Top 10 Postcodes voor MBO Amersfoort",
        subtitle = "Gerangschikt op aantal studenten"
    ) %>%
    cols_label(
        jaar = "Jaar",
        postcode_4 = "Postcode",
        mbo_amersfoort_students = "MBO Studenten",
        postcode_percentage = "Percentage van MBO (%)"
    ) %>%
    fmt_number(
        columns = mbo_amersfoort_students,
        decimals = 0
    ) %>%
    fmt_number(
        columns = postcode_percentage,
        decimals = 1
    ) %>%
    tab_style(
        style = cell_fill(color = "#e6f3ff"),
        locations = cells_body(rows = jaar == 2023)
    ) %>%
    tab_style(
        style = cell_fill(color = "#fff2e6"),
        locations = cells_body(rows = jaar == 2024)
    )

```

### Inzichten Geografische Analyse

De geografische analyse van MBO Amersfoort studentenherkomst toont interessante patronen:

1. **Geografische Concentratie**: MBO Amersfoort studenten komen voornamelijk uit bepaalde postcodegebieden, met duidelijke concentraties
2. **Herkomstverdeling**: Het percentage studenten per postcode varieert significant, waarbij alle percentages per jaar optellen tot 100%
3. **Jaarlijkse Vergelijking**: Door 2023 en 2024 te vergelijken kunnen we trends in geografische herkomst identificeren
4. **Strategische Inzichten**: De kaarten tonen waar MBO Amersfoort haar studentenpopulatie vandaan haalt

Deze analyse kan gebruikt worden voor:
- Identificatie van kerngebieden voor studentenwerving
- Begrijpen van geografische bereik en aantrekkingskracht
- Optimalisatie van locatiestrategie en bereikbaarheid
- Analyse van veranderingen in studentenherkomst over tijd

Tot slot analyseren we de verdeling van aanmeldingsstatussen per maand en jaar. Dit geeft inzicht in het verloop van het administratieve proces gedurende het jaar.


```{r}
#| label: status-by-month

# First, prepare the base data with needed identifiers and date calculation
status_by_week_base <- applications_enriched %>%
  #filter(opleidingcode == 25699) %>%
  # Filter only for school year 2024
  filter(schooljaar == 2024) %>%
  # Process date and week information
  mutate(
    begindatum = as.Date(begindatum),
    # Week calculation
    week_of_year = week(begindatum),
    year_of_date = year(begindatum),
    
    # Calculate academic week number
    academic_week = case_when(
      month(begindatum) >= 10 ~ week_of_year - week(as.Date(paste0(year_of_date, "-10-01"))) + 1,
      TRUE ~ week_of_year + (52 - week(as.Date(paste0(year_of_date-1, "-10-01")))) + 1
    ),
    
    academic_month = if_else(month(begindatum) >= 10, 
                             month(begindatum) - 9,
                             month(begindatum) + 3),
    
    # Categorize status
    status_category = case_when(
      status == "SUBMITTED" ~ "Submitted",
      status == "RECEIVED" ~ "Received",
      status == "OFFERED" ~ "Offered", 
      status == "ENROLLED" ~ "Enrolled",
      status == "REJECTED" ~ "Rejected",
      status == "WITHDRAWN" ~ "Withdrawn",
      TRUE ~ "Other"
    )
  )

# Get the unique application identifiers
application_identifiers <- status_by_week_base %>%
  select(bsnhash, schooljaar, opleidingcode, instellingserkenningscode) %>%
  distinct()

# Count new status entries by week
new_status_by_week <- status_by_week_base %>%
  # Group by application and week
  group_by(
    bsnhash, schooljaar, opleidingcode, instellingserkenningscode,
    academic_week, academic_month, status_category
  ) %>%
  # Just count the occurrences (taking the most recent status per application per week)
  summarise(
    count = n_distinct(bsnhash, opleidingcode, instellingserkenningscode),
    .groups = "drop"
  )

# Count status transitions by week
status_transitions <- status_by_week_base %>%
  # Sort by date within each application group
  arrange(bsnhash, schooljaar, opleidingcode, instellingserkenningscode, begindatum) %>%
  # Group by application
  group_by(bsnhash, schooljaar, opleidingcode, instellingserkenningscode) %>%
  # Calculate status transitions
  mutate(
    prev_status = lag(status_category),
    prev_week = lag(academic_week)
  ) %>%
  # Filter to only status transitions
  filter(!is.na(prev_status) & status_category != prev_status) %>%
  # Group by week and status transition type
  group_by(academic_week, academic_month, prev_status, status_category) %>%
  # Count transitions
  summarise(
    transition_count = n(),
    .groups = "drop"
  )

# Calculate running counts of status for each week
status_running_counts <- new_status_by_week %>%
  # Get full range of academic weeks
  full_join(
    tibble(academic_week = min(new_status_by_week$academic_week):max(new_status_by_week$academic_week)),
    by = "academic_week"
  ) %>%
  # Make sure all status categories are represented in all weeks
  complete(academic_week, status_category, fill = list(count = 0)) %>%
  # Add month information
  group_by(academic_week) %>%
  mutate(
    academic_month = first(academic_month[!is.na(academic_month)])
  ) %>%
  ungroup()

# Calculate the running status counts
# Starting with zero counts for all statuses
all_weeks <- sort(unique(status_running_counts$academic_week))
all_statuses <- unique(status_running_counts$status_category)

# Initialize results dataframe
result <- data.frame()

# Build running counts matrix
status_counts <- matrix(0, nrow = length(all_weeks), ncol = length(all_statuses))
colnames(status_counts) <- all_statuses
rownames(status_counts) <- all_weeks

# For each week, adjust counts based on status transitions
for (i in 1:length(all_weeks)) {
  week <- all_weeks[i]
  
  # If we're past the first week, start with previous week's counts
  if (i > 1) {
    status_counts[i,] <- status_counts[i-1,]
  }
  
  # Add new entries from this week
  week_new <- new_status_by_week %>% 
    filter(academic_week == week)
  
  for (j in 1:nrow(week_new)) {
    status <- week_new$status_category[j]
    status_counts[i, status] <- status_counts[i, status] + week_new$count[j]
  }
  
  # Apply transitions from previous statuses
  week_transitions <- status_transitions %>% 
    filter(academic_week == week)
  
  for (j in 1:nrow(week_transitions)) {
    from_status <- week_transitions$prev_status[j]
    to_status <- week_transitions$status_category[j]
    trans_count <- week_transitions$transition_count[j]
    
    # Decrease count for previous status
    status_counts[i, from_status] <- status_counts[i, from_status] - trans_count
    # Increase count for new status (already done by adding new entries)
  }
  
  # Add results to output dataframe
  for (status in all_statuses) {
    result <- rbind(result, data.frame(
      academic_week = week,
      status_category = status,
      count = status_counts[i, status]
    ))
  }
}

# Add month information
result <- result %>%
  left_join(
    status_by_week_base %>% 
      select(academic_week, academic_month) %>% 
      distinct(),
    by = "academic_week"
  )

# Calculate total per week for percentages
week_totals <- result %>%
  group_by(academic_week) %>%
  summarise(total = sum(count), .groups = "drop")

# Add percentages
result <- result %>%
  left_join(week_totals, by = "academic_week") %>%
  mutate(percentage = count / total * 100)

# Define color palette with different intensities
status_colors <- c(
  "Submitted" = "#a9cce3",     # Very light blue
  "Received" = "#2980b9",        # Light blue
  "Offered" = "#1a5276",       # Medium blue
  "Enrolled" = "darkgreen",      # Dark blue
  "Rejected" = "#e74c3c",      # Red (contrast)
  "Withdrawn" = "#f39c12",     # Orange (contrast)
  "Other" = "#95a5a6"          # Gray
)

# Determine which weeks correspond to the start of each month for the x-axis
month_start_weeks <- result %>%
  filter(!is.na(academic_month)) %>%
  group_by(academic_month) %>%
  summarise(start_week = min(academic_week), .groups = "drop")

# Create vector of labels for the x-axis
academic_month_labels <- c("Okt", "Nov", "Dec", "Jan", "Feb", "Mrt", 
                         "Apr", "Mei", "Jun", "Jul", "Aug", "Sep")

```


```{r}
#| label: status-by-month-plot
ggplot(result, 
       aes(x = academic_week, y = count, 
           fill = status_category, group = status_category)) +
    geom_area(position = "stack", alpha = 0.8) +
    scale_fill_manual(values = status_colors) +
    theme_minimal() +
    labs(title = "Aantal Aanmeldingen per Status per Week",
         subtitle = "Schooljaar 2024",
         x = "Week (academisch jaar)",
         y = "Aantal Aanmeldingen",
         fill = "Status") +
    scale_x_continuous(
        breaks = month_start_weeks$start_week,
        labels = academic_month_labels[month_start_weeks$academic_month],
        expand = c(0, 0)
    ) +
    scale_y_continuous(labels = comma,
                       expand = c(0, 0)) +
    theme(
        panel.grid.minor = element_blank(),
        legend.position = "bottom"
    )
```


```{r}

test <- sf::st_read("data/reference/cbs_pc4_2024_v1.gpkg")

test2 <- test %>% mutate(aantal_inwoners = ifelse(aantal_inwoners < 0, 0, aantal_inwoners))

# Transform from Amersfoort/RD New (EPSG:28992) to WGS84 (EPSG:4326)
test2_wgs84 <- st_transform(test2, crs = 4326)
centroids <- st_centroid(test2_wgs84)

# Create a basic leaflet map
# Better scaling function for bubble sizes
scale_radius <- function(x, min_size = 5, max_size = 50) {
    # Scale between min and max size
    scaled <- (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
    return(min_size + scaled * (max_size - min_size))
}

leaflet(centroids) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    addCircles(
        radius = ~scale_radius(aantal_inwoners, min_size = 5, max_size = 2000),
        fillOpacity = 0.7,
        color = "white",
        fillColor = "steelblue",
        weight = 1,
        popup = ~paste0(
            "<b>Postcode:</b> ", postcode, "<br>",
            "<b>Aantal inwoners:</b> ", format(aantal_inwoners, big.mark = ",")
        ),
        label = ~paste(postcode, "-", format(aantal_inwoners, big.mark = ","), "inwoners")
    )

# Transform to WGS84
test2_wgs84 <- st_transform(test2, crs = 4326)

# Create simple color function (white to red)
color_scale <- function(x) {
  # Normalize values between 0 and 1
  normalized <- (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
  
  # Create RGB values (white = 255,255,255 to red = 255,0,0)
  red_values <- rep(255, length(x))
  green_values <- round(255 * (1 - normalized))
  blue_values <- round(255 * (1 - normalized))
  
  # Return hex colors
  return(rgb(red_values, green_values, blue_values, maxColorValue = 255))
}

# Create the map
leaflet(test2_wgs84) %>%
  addTiles() %>%
  addPolygons(
    fillColor = ~color_scale(aantal_inwoners),
    fillOpacity = 1,
    color = "white",
    weight = 1,
    popup = ~paste0(
      "<b>Postcode:</b> ", postcode, "<br>",
      "<b>Aantal inwoners:</b> ", format(aantal_inwoners, big.mark = ",")
    ),
    label = ~paste(postcode, "-", format(aantal_inwoners, big.mark = ","), "inwoners"),
    highlightOptions = highlightOptions(
      weight = 2,
      color = "black",
      fillOpacity = 0.9,
      bringToFront = TRUE
    )
  )

```

### Inzichten Temporele Analyse
De temporele analyse biedt essentiële inzichten voor planning en optimalisatie:

Er zijn duidelijke seizoenspatronen in aanmeldingen, met pieken in bepaalde maanden die consistent zijn tussen jaren
Het conversiepercentage varieert significant gedurende het jaar, waarbij vroege aanmeldingen vaak een hogere conversiekans hebben
De statusverdeling laat zien dat er een natuurlijke progressie is van statuswijzigingen gedurende het jaar
2023 en 2024 vertonen vergelijkbare patronen, maar met enkele opvallende verschillen die nader onderzoek verdienen

Deze inzichten zijn cruciaal voor:

1. Het optimaliseren van marketingcampagnes op basis van seizoenspatronen
2. Het verbeteren van het administratieve proces voor tijdige statusveranderingen
3. Het beter plannen van capaciteit gedurende piekmomenten
4. Het identificeren van trends die aanvullende aandacht vereisen

## Vervolg
Deze analyse vormt de basis voor een dashboard implementatie. Belangrijke bevindingen die we willen benadrukken in het interactieve dashboard:

1. Er zijn duidelijk patronen in verloop aanmeldingenn
2. Het aantal andere aanmeldingen speelt grote rol bij conversie
3. Per instellingen en opleiding zijn er duidelijke verschillen

Inhoudelijk zouden we ook graag kijken naar:

1. Geografische patronen in de herkomst van aanmeldingen
2. Patronen in overlap tussen instellingen en opleidingen

De volgende stappen zijn:

1. Deze analyses verfijnen op basis van feedback van stakeholders
2. De statische visualisaties omzetten naar interactieve componenten
3. De filterfunctionaliteit implementeren
4. Back-end van een app bouwen

