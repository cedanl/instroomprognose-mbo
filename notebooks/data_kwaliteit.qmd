---
title: "Koppelpunt MBO - Data kwaliteit"
subtitle: "Inzichten in data kwaliteit"
author: "Corneel den Hartogh"
affiliation: "CEDA - Npuls"
date: "`r format(Sys.time(), '%d %B %Y')`"
format: 
  html:
    toc: true
    toc-title: Inhoudsopgave
    code-fold: true
    code-summary: "Laat code zien"
  pdf:
    toc: true
    toc-title: Inhoudsopgave
    #number-sections: true
    #colorlinks: true
    echo: false
execute:
  cache: true
  freeze: auto
  include: true
  warning: false
---

```{r}
#| label: setup
#| cache: false
#| output: false
#| include: false
#| freeze: false

# Load required libraries
source("utils/00_setup.R")
# Set config, change to cambo to run with real data from cambo
Sys.setenv(R_CONFIG_ACTIVE = "cambo")
```

## 1. Data inladen & toevoegen

We laden het basis-bestand en de referentiedata (BRIN en opleidingen) in. 

```{r}
#| label: load-data
#| freeze: true
#| cache: false

applications_filepath <- file.path(config::get("data_base_dir"),
                                   config::get("applications_filename"))

applications <- safe_read_csv(applications_filepath, 
                      delim = ",",
                      col_types = cols(postcodecijfers = "c",
                                       .default = col_guess()))

# Load reference data
brin <- read_excel("data/reference/BRIN.xlsx")
programmes <- read_excel("data/reference/Opleiding_dimensie.xlsx")

```

We voegen de referentie data toe aan het bronbestand.

```{r}
#| label: enrich-data
#| cache: false
#| freeze: false
# Join with reference data
applications_enriched <- applications %>%
    # Convert opleidingcode to integer for joining (drops a small % of non-numeric values)
    mutate(opleidingcode = as.integer(opleidingcode)) %>%
    left_join(programmes, by = c("opleidingcode" = "Opleidingcode")) %>%
    left_join(brin, by = c("instellingserkenningscode" = "BRIN"))

```

## 2. Data kwaliteit

### 2.1. Postcode kwaliteit

We analyseren hoeveel aanmeldingen niet voldoen aan het Nederlandse postcode formaat (4 cijfers), verdeeld over de schooljaren.

```{r}
#| label: postcode-analyse
#| warning: false
#| freeze: false
#| cache: false

# Definieer een functie om te controleren of postcodecijfers geldig is
# Geldige postcodecijfers bestaan uit precies 4 numerieke karakters
is_valid_postcode_digits <- function(postcodecijfers) {
    # Vectorized functie die NA's en niet-valide postcodes afhandelt
    ifelse(is.na(postcodecijfers), FALSE, grepl("^\\d{4}$", postcodecijfers))
}

# Check de postcodecijfers validiteit
applications_enriched <- applications_enriched %>%
    mutate(
        valid_postcode = is_valid_postcode_digits(postcodecijfers),
        schooljaar = factor(schooljaar) # Zorg dat schooljaar als factor wordt behandeld
    )

# Tellingen per schooljaar
postcode_validation_by_year <- applications_enriched %>%
    group_by(schooljaar) %>%
    summarise(
        totaal_aanmeldingen = n(),
        geldige_postcodes = sum(valid_postcode, na.rm = TRUE),
        ongeldige_postcodes = sum(!valid_postcode, na.rm = TRUE),
        percentage_ongeldig = round(ongeldige_postcodes / totaal_aanmeldingen * 100, 2)
    ) %>%
    arrange(schooljaar)

# Toon resultaten
knitr::kable(postcode_validation_by_year, 
             caption = "Ongeldige postcodes per schooljaar",
             col.names = c("Schooljaar", "Totaal aanmeldingen", "Geldige postcodes", 
                          "Ongeldige postcodes", "% Ongeldig"))

# Visualisatie
ggplot(postcode_validation_by_year, aes(x = schooljaar, y = ongeldige_postcodes)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    geom_text(aes(label = percentage_ongeldig), vjust = -0.5) +
    labs(
        title = "Aantal ongeldige postcodes per schooljaar",
        subtitle = "Ongeldige postcodes bevatten niet precies 4 cijfers",
        x = "Schooljaar",
        y = "Aantal ongeldige postcodes"
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### 2.1.1. Meest voorkomende ongeldige postcodes

Laten we ook kijken naar de meest voorkomende ongeldige postcodecijfers-patronen:

```{r}
#| label: postcode-patroon-analyse

# Top 10 ongeldige postcodes
top_invalid_postcodes <- applications_enriched %>%
    filter(!valid_postcode) %>%
    count(postcodecijfers, sort = TRUE) %>%
    filter(n > 1)

knitr::kable(top_invalid_postcodes, 
             caption = "Meest voorkomende ongeldige postcodes",
             col.names = c("Postcodecijfers", "Aantal"))

```

### 2.2. Schooljaar kwaliteit

Uit de eerdere analyses blijkt dat de variabele 'schooljaar' niet altijd correct is ingevuld, met name voor de waarde '0'. Ook zien we dat het schooljaar soms tot verwarring leidt (klopt het wel?).

#### 2.2.1. Afgeleide schooljaar

We leiden daarom een nieuwe schooljaar-variabele af op basis van de 'created_date' en startmoment. 

```{r}
#| label: derive-school-year
#| cache: false
#| freeze: false

# Zorg ervoor dat de datum kolommen daadwerkelijk als datum zijn geformatteerd
applications_with_dates <- applications_enriched %>%
    mutate(
        created_date_parsed = as.Date(createdat),
        begindatum_parsed = as.Date(begindatum)
    )

# Controleer of parsing succesvol was
no_dates <- is.na(applications_with_dates$created_date_parsed) |> sum()

if (no_dates > 0) {
    warning(paste("Er zijn", no_dates, "datums niet correct geparsed."))
}

# Voeg afgeleide schooljaar toe op basis van created_date en begindatum
applications_with_derived <- applications_with_dates |>
  mutate(
    schooljaar_afgeleid_created = case_when(
      is.na(created_date_parsed) ~ NA_integer_,
      month(created_date_parsed) >= 10 ~ year(created_date_parsed) + 1,
      month(created_date_parsed) < 10 ~ year(created_date_parsed),
      .default = NA_integer_),
    schooljaar_afgeleid_startmoment = case_when(
      is.na(startmoment) ~ NA_integer_,
      month(startmoment) >= 8 ~ year(startmoment),
      month(startmoment) < 8 ~ year(startmoment) - 1,
      .default = NA_integer_)
    )
    
applications_with_conclusion <- applications_with_derived %>%
  mutate(
    schooljaar = as.integer(as.character(schooljaar)),
    schooljaar_afgeleid = case_when(
      # Alles hetzelfde
      schooljaar == schooljaar_afgeleid_startmoment & 
        schooljaar == schooljaar_afgeleid_created ~ schooljaar,
      # Als schooljaar 0 is, dan is er geen startmoment
      schooljaar == 0 ~ schooljaar_afgeleid_created,
      # Soms is er een vroege aanmelding in augustus of september
      schooljaar == schooljaar_afgeleid_startmoment &
        schooljaar_afgeleid_created == schooljaar - 1 &
        month(created_date_parsed) %in% c(8,9) ~ schooljaar,
      # Soms is er een late aanmelding op 1 oktober
      schooljaar == schooljaar_afgeleid_startmoment &
        schooljaar_afgeleid_created == schooljaar + 1 &
        month(created_date_parsed) == 10 &
        day(created_date_parsed) == 1 ~ schooljaar,
      # Soms is er een na-inschrijving
      schooljaar == schooljaar_afgeleid_startmoment &
        schooljaar_afgeleid_created == schooljaar + 1 &
        created_date_parsed < startmoment ~ schooljaar,
      # Inschrijving op 10-1 jaar later waarbij created 2 jaar rekent
      schooljaar == schooljaar_afgeleid_startmoment &
        schooljaar_afgeleid_created > schooljaar + 1 &
        month(created_date_parsed) == 10 &
        day(created_date_parsed) == 1 ~ schooljaar_afgeleid_created - 1,
      # Bij overige gaan we uit van created
      schooljaar_afgeleid_created > schooljaar ~ schooljaar_afgeleid_created,
      .default = schooljaar
    )
  ) %>%
 # Verwijder rijen met missende waarden in essentiële velden
 filter(!is.na(status), !is.na(begindatum)) %>%
 # Creëer een unieke case_id (student + opleiding + instelling)
 mutate(
   case_id = paste(ketenid, bsnhash, schooljaar_afgeleid, opleidingcode, instellingserkenningscode, onderwijslocatiecode, sep = "_")
 )
```


```{r}
#| label: schooljaar-comparison-analysis

test <- applications_with_conclusion |>
  mutate(veranderd = schooljaar != schooljaar_afgeleid) |>
  group_by(schooljaar_afgeleid) |>
  summarise(n = n(),
         veranderd = sum(veranderd, na.rm = TRUE),
         percentage_veranderd = sum(veranderd, na.rm = TRUE) / n(),
         .groups = "drop")

test2 <- applications_with_conclusion |>
  mutate(veranderd = schooljaar != schooljaar_afgeleid) |>
  group_by(schooljaar) |>
  summarise(n = n(),
         veranderd = sum(veranderd, na.rm = TRUE),
         percentage_veranderd = sum(veranderd, na.rm = TRUE) / n(),
         .groups = "drop")

# Vergelijk originele schooljaar met afgeleide schooljaren
schooljaar_comparison <- applications_with_conclusion %>%
  group_by(schooljaar, schooljaar_afgeleid) %>%
  summarise(
    aantal = n(), .groups = "drop"
  ) %>%
  #filter(!is.na(schooljaar_afgeleid_created)) %>%
  arrange(schooljaar,
          schooljaar_afgeleid)

knitr::kable(schooljaar_comparison, 
             caption = "Vergelijking tussen originele schooljaar en afgeleide schooljaar (op basis van created_date)",
             col.names = c("Originele schooljaar", "Afgeleid schooljaar", "Aantal"))

# Visualisatie van de vergelijking
# Omgekeerde visualisatie met IBCS kleuren
ggplot(schooljaar_comparison, aes(x = factor(schooljaar_afgeleid), y = aantal, fill = factor(schooljaar))) +
    geom_bar(stat = "identity", position = "stack") +
    scale_fill_manual(values = c(
        "0" = "#E8A15D",     # Donkerblauw "
        "2021" = "#B4C7E7",  # Lichtblauw
        "2022" = "#8FAADC",  # Middenblauw
        "2023" = "#5B9BD5",  # Blauw
        "2024" = "#4472C4"  # Donkerblauw
    )) +
    labs(
        title = "Verdeling van afgeleid schooljaar versus origineel schooljaar",
        subtitle = "Afgeleid op basis van datum en startmoment",
        x = "Afgeleid schooljaar",
        y = "Aantal statusveranderingen",
        fill = "Origineel schooljaar"
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


#### 2.2.2. Nieuwe rijen toevoegen

```{r}
#| label: define-closure-function

add_process_closure_events <- function(process_data) {
  
  # Identificeer finale statussen
  final_statuses <- c("ENROLLED", "REJECTED", "WITHDRAWN")
  
  # Step 1: Detecteer case switches per student
  student_cases <- process_data %>%
    select(bsnhash, case_id, begindatum) %>%
    distinct() %>%
    arrange(bsnhash, begindatum) %>%
    group_by(bsnhash) %>%
    mutate(
      next_case_id = lead(case_id),
      next_case_begindatum = lead(begindatum),
      # Als case_id verandert, oude case moet afgesloten worden
      needs_closure_by_new_case = case_id != next_case_id & !is.na(next_case_id)
    ) %>%
    ungroup()
  
  # Step 2: Identificeer welke cases al afgesloten zijn
  case_final_status <- process_data %>%
    group_by(case_id) %>%
    arrange(begindatum) %>%
    summarise(
      last_status = last(status),
      last_date = last(begindatum),
      is_already_closed = last_status %in% final_statuses,
      .groups = "drop"
    )
  
  # Step 3: Genereer WITHDRAWN events voor case switches
  closure_by_new_case <- student_cases %>%
    filter(needs_closure_by_new_case) %>%
    left_join(case_final_status, by = "case_id") %>%
    filter(!is_already_closed) %>%  # Alleen als nog niet afgesloten
    transmute(
      case_id = case_id,
      status = "WITHDRAWN",
      begindatum = next_case_begindatum,  # Withdrawn op moment van nieuwe aanmelding
      closure_reason = "new_application"
    )
  
  # Step 4: Genereer WITHDRAWN events voor 1 oktober cutoff
  # Bepaal 1 oktober per schooljaar
  october_cutoffs <- process_data %>%
    select(case_id, schooljaar_afgeleid) %>%
    distinct() %>%
    mutate(
      october_cutoff = as.Date(paste0(schooljaar_afgeleid, "-10-01"))
    )
  
  closure_by_cutoff <- case_final_status %>%
    filter(!is_already_closed) %>%  # Alleen nog openstaande cases
    left_join(october_cutoffs, by = "case_id") %>%
    filter(!is.na(october_cutoff)) %>%
    # Alleen als laatste activiteit voor 1 oktober was
    filter(last_date < october_cutoff) %>%
    transmute(
      case_id = case_id,
      status = "WITHDRAWN",
      begindatum = october_cutoff,
      closure_reason = "october_cutoff"
    )
  
  # Step 5: Combineer alle closure events
  all_closure_events <- bind_rows(
    closure_by_new_case,
    closure_by_cutoff
  ) %>%
    # Voeg andere benodigde kolommen toe (van originele data)
    left_join(
      process_data %>% 
        select(case_id, bsnhash, ketenid, schooljaar_afgeleid, opleidingcode, 
               instellingserkenningscode, onderwijslocatiecode) %>% 
        distinct(),
      by = "case_id"
    )
  
  # Step 6: Voeg closure events toe aan originele data
  enhanced_process_data <- bind_rows(
    process_data,
    all_closure_events %>% select(-closure_reason)  # Verwijder hulpkolom
  ) %>%
    arrange(case_id, begindatum)
  
  # Return ook overzicht van toegevoegde events voor validatie
  list(
    data = enhanced_process_data,
    added_events = all_closure_events %>%
      count(closure_reason, name = "events_added")
  )
}

```


```{r}
#| label: apply-closure-events
#| cache: false

# Bestaande preparatie code...
applications_prepare_expansion <- applications_with_conclusion %>%
  group_by(case_id) %>%
  mutate(complete = lead(begindatum),
         status_towards = lead(status))

# NIEUWE STAP: Voeg closure events toe
closure_result <- add_process_closure_events(applications_prepare_expansion)
applications_expanded <- closure_result$data



# Gebruik enhanced data voor process mining
# log <- process_data_mboa_enhanced %>%
#   convert_timestamps(c("start", "complete"), format = ymd_hms) |>
#   activitylog(
#    case_id = "case_id",
#    activity_id = "activity", 
#    timestamps = c("start", "complete"),
#    resource_id = "instellingserkenningscode",
#    order = "auto"
#  )

```

### 2.3. Inzicht in veranderingen

#### 2.3.1. Afgeleid schooljaar

```{r}
#| label: yearly-metrics-analysis
yearly_metrics_afgeleid <- applications_with_conclusion %>%
  group_by(schooljaar_afgeleid) %>%
  summarise(
    total_applications = n(),
    unique_students = n_distinct(bsnhash),
    conversion_rate = mean(status == "ENROLLED", na.rm = TRUE) * 100,
    .groups = "drop"
  ) %>%
  arrange(schooljaar_afgeleid)

yearly_metrics_afgeleid %>%
  pivot_longer(cols = c(total_applications, unique_students), 
               names_to = "metric", 
               values_to = "value") %>%
  mutate(metric = if_else(metric == "total_applications", 
                         "Aantal Statusveranderingen", 
                         "Unieke Studenten")) %>%
  ggplot(aes(x = factor(schooljaar_afgeleid), y = value, group = metric, color = metric)) +
  geom_line() +
  geom_point(size = 2) +
  theme_minimal() +
  labs(title = "Trend van Aanmeldingen per Jaar",
       subtitle = "Vergelijking tussen aantal statusveranderingen en unieke studenten",
       x = "Schooljaar",
       y = "Aantal",
       color = "Metriek") +
  scale_y_continuous(labels = comma) +
  scale_color_manual(values = c("Aantal Statusveranderingen" = "#4393C3", "Unieke Studenten" = "#E8A15D")) +
  theme(legend.position = "bottom")

```

We zien dat alle waardes 0 zijn omgezet naar naar daadwerkelijke jaren. Ook zien we dat voor andere jaren dan 2023 en 2024 het aantal aanwezige aanmeldingsstatussen veel lager is.

#### 2.3.2. Inzicht in toegevoegde rijen

Toon hoeveel events toegevoegd zijn

```{r}
#| label: show-added-events

closure_result$added_events %>%
  knitr::kable(caption = "Toegevoegde WITHDRAWN events voor process closure")

```

## 3. Process mining

Bij een administratief proces is de data-kwaliteit de proces-kwaliteit. Door met process mining een zogenoemde procesmap maken, krijgen we een indruk van de procesrkwaliteit.

We maken drie verschillende analyses om de impact van verschillende data-keuzes te vergelijken:

1. **Origineel**: `applications_with_conclusion` met originele `schooljaar`
2. **Afgeleid schooljaar**: `applications_with_conclusion` met `schooljaar_afgeleid`  
3. **Aanvullende rijen**: `applications_expanded` met `schooljaar_afgeleid`

### Preparatie data varianten

```{r}
#| label: process-mining-setup
# Functie om proces data voor te bereiden
prepare_process_data <- function(data, schooljaar_var = "schooljaar_afgeleid") {
  
  # Maak case_id op basis van gekozen schooljaar variabele
  if (schooljaar_var == "schooljaar") {
    data <- data %>%
      mutate(case_id_temp = paste(ketenid, bsnhash, schooljaar, opleidingcode, 
                                  instellingserkenningscode, onderwijslocatiecode, sep = "_"))
  } else {
    data <- data %>%
      mutate(case_id_temp = case_id)  # Gebruik bestaande case_id
  }
  
  # Selecteer en hernoem kolommen
  data %>%
    select(
      bsnhash,
      ketenid,
      status,
      begindatum,
      opleidingcode,
      instellingserkenningscode,
      onderwijslocatiecode,
      schooljaar_var = all_of(schooljaar_var),
      case_id = case_id_temp
    ) %>%
    rename(
      activity = status,
      start = begindatum
    )
}

# Prepareer de drie varianten
process_data_origineel <- prepare_process_data(applications_with_conclusion, "schooljaar")
process_data_afgeleid <- prepare_process_data(applications_with_conclusion, "schooljaar_afgeleid")
process_data_aanvullend <- prepare_process_data(applications_expanded, "schooljaar_afgeleid")
```

### Vergelijking van datasets

Laten we eerst kijken naar de verschillen tussen de drie datasets:

```{r}
#| label: dataset-comparison
# Vergelijk aantal cases en activiteiten per dataset
dataset_stats <- tibble(
  Dataset = c("Origineel schooljaar", "Afgeleid schooljaar", "Aanvullende rijen"),
  `Aantal cases` = c(
    n_distinct(process_data_origineel$case_id), 
    n_distinct(process_data_afgeleid$case_id),
    n_distinct(process_data_aanvullend$case_id)
  ),
  `Aantal activiteiten` = c(
    nrow(process_data_origineel),
    nrow(process_data_afgeleid),
    nrow(process_data_aanvullend)
  ),
  `Gemiddeld per case` = round(`Aantal activiteiten` / `Aantal cases`, 2)
)

knitr::kable(dataset_stats, caption = "Vergelijking van datasets voor process mining")
```

### Process mining per variant

Voor het maken van proces maps zoomen we in op één instelling: MBO Amersfoort (30RR).

```{r}
#| label: process-mining-eventlogs
# Functie om eventlog te maken per variant
create_eventlog <- function(process_data, variant_name) {
  
  process_data_mboa <- process_data %>%
    filter(instellingserkenningscode == "30RR") %>%
    group_by(case_id) %>%
    mutate(complete = lead(start),
           activity_towards = lead(activity))
  
  log <- process_data_mboa %>%
    convert_timestamps(c("start", "complete"), format = ymd_hms) %>%
    activitylog(
      case_id = "case_id",
      activity_id = "activity", 
      timestamps = c("start", "complete"),
      resource_id = "instellingserkenningscode",
      order = "auto"
    )
  
  return(log)
}

# Maak eventlogs voor alle drie varianten
log_origineel <- create_eventlog(process_data_origineel, "origineel")
log_afgeleid <- create_eventlog(process_data_afgeleid, "afgeleid")
log_aanvullend <- create_eventlog(process_data_aanvullend, "aanvullend")
```
 

### Proces maps - Vergelijking van varianten

Nu maken we proces maps voor alle drie varianten om de verschillen te kunnen vergelijken.

#### 3.1 Origineel schooljaar variant (applications_with_conclusion + schooljaar)

```{r}
#| label: process-map-origineel
process_map_origineel <- process_map(
  log_origineel,
  layout = layout_pm(edge_weight = TRUE, edge_cutoff = 1), 
  rankdir = "TB", 
  type_nodes = frequency("relative_case"), 
  type_edges = frequency("relative_case"), 
  render = FALSE
)

if (knitr::is_html_output() | interactive()) {
  processmapR::render_map(process_map_origineel)
} else {
  map_file <- "data_kwaliteit_files/figure-pdf/process-map-origineel.pdf"
  processmapR::export_map(process_map_origineel, file_name = map_file)
  knitr::include_graphics(map_file)
}
```

#### 3.2 Afgeleid schooljaar variant (applications_with_conclusion + schooljaar_afgeleid)

```{r}
#| label: process-map-afgeleid
process_map_afgeleid <- process_map(
  log_afgeleid,
  layout = layout_pm(edge_weight = TRUE, edge_cutoff = 1), 
  rankdir = "TB", 
  type_nodes = frequency("relative_case"), 
  type_edges = frequency("relative_case"), 
  render = FALSE
)

if (knitr::is_html_output() | interactive()) {
  processmapR::render_map(process_map_afgeleid)
} else {
  map_file <- "data_kwaliteit_files/figure-pdf/process-map-afgeleid.pdf"
  processmapR::export_map(process_map_afgeleid, file_name = map_file)
  knitr::include_graphics(map_file)
}
```

#### 3.3 Aanvullende rijen variant (applications_expanded + schooljaar_afgeleid)

```{r}
#| label: process-map-aanvullend
process_map_aanvullend <- process_map(
  log_aanvullend,
  layout = layout_pm(edge_weight = TRUE, edge_cutoff = 1), 
  rankdir = "TB", 
  type_nodes = frequency("relative_case"), 
  type_edges = frequency("relative_case"), 
  render = FALSE
)

if (knitr::is_html_output() | interactive()) {
  processmapR::render_map(process_map_aanvullend)
} else {
  map_file <- "data_kwaliteit_files/figure-pdf/process-map-aanvullend.pdf"
  processmapR::export_map(process_map_aanvullend, file_name = map_file)
  knitr::include_graphics(map_file)
}
```

### Gefilterde proces maps (>5% flows)

We zien naast de standaard flow (submitted -> received -> offered -> enrolled) ook veel andere flows. Voor overzicht filteren we op flows die meer dan 5% van de gevallen bevatten.

```{r}
#| label: process-maps-filtered
# Functie om proces map te filteren op >5% flows
filter_process_map <- function(process_map, threshold = 0.05) {
  
  edges_to_remove <- process_map %>%
    processmapR::get_flows() %>%
    dplyr::filter(value < threshold) %>%
    transmute(from = from_id, to = to_id)
  
  edges_ids_to_remove <- process_map %>%
    DiagrammeR::get_edge_df() %>%
    as_tibble() %>%
    semi_join(edges_to_remove, by = c("from", "to")) %>%
    pull(id)
  
  filtered_map <- process_map %>%
    DiagrammeR::select_edges_by_edge_id(edges = edges_ids_to_remove) %>%
    DiagrammeR::delete_edges_ws() %>%
    DiagrammeR::select_nodes_by_degree("deg == 0") %>%
    DiagrammeR::delete_nodes_ws()
  
  return(filtered_map)
}

# Filter alle drie process maps
process_map_origineel_filtered <- filter_process_map(process_map_origineel)
process_map_afgeleid_filtered <- filter_process_map(process_map_afgeleid)
process_map_aanvullend_filtered <- filter_process_map(process_map_aanvullend)
```

#### 3.4 Vergelijking gefilterde maps

**Origineel schooljaar variant (gefilterd):**
```{r}
#| label: origineel-filtered
if (knitr::is_html_output() | interactive()) {
  processmapR::render_map(process_map_origineel_filtered)
} else {
  map_file <- "data_kwaliteit_files/figure-pdf/process-map-origineel-filtered.pdf"
  processmapR::export_map(process_map_origineel_filtered, file_name = map_file)
  knitr::include_graphics(map_file)
}
```

**Afgeleid schooljaar variant (gefilterd):**
```{r}
#| label: afgeleid-filtered
if (knitr::is_html_output() | interactive()) {
  processmapR::render_map(process_map_afgeleid_filtered)
} else {
  map_file <- "data_kwaliteit_files/figure-pdf/process-map-afgeleid-filtered.pdf"
  processmapR::export_map(process_map_afgeleid_filtered, file_name = map_file)
  knitr::include_graphics(map_file)
}
```

**Aanvullende rijen variant (gefilterd):**
```{r}
#| label: aanvullend-filtered
if (knitr::is_html_output() | interactive()) {
  processmapR::render_map(process_map_aanvullend_filtered)
} else {
  map_file <- "data_kwaliteit_files/figure-pdf/process-map-aanvullend-filtered.pdf"
  processmapR::export_map(process_map_aanvullend_filtered, file_name = map_file)
  knitr::include_graphics(map_file)
}
```

### Samenvatting proces mining verschillen

De drie varianten laten verschillende aspecten van het proces zien:

- **Origineel schooljaar**: Behoudt oorspronkelijke data maar met inconsistenties (schooljaar=0)
- **Afgeleid schooljaar**: Gebruikt afgeleide schooljaren voor consistente case definitie  
- **Aanvullende rijen**: Voegt extra WITHDRAWN events toe voor proces-completheid

De standaard flow (submitted → received → offered → enrolled) is zichtbaar in alle varianten, maar de aanvullende rijen variant toont meer complete proces-afsluitingen.
